// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none
// @generated from protobuf file "chat/client_v2_rpc/rpc.proto" (package "stream.chat.client_v2_rpc", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ClientRPC } from "./rpc";
import type { QueryChannelsResponse } from "./channel";
import type { QueryChannelsRequest } from "./channel";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { GetChannelResponse } from "./channel";
import type { GetChannelRequest } from "./channel";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * ClientRPC specific RPC methods.
 * for end-user interactions.
 *
 * @generated from protobuf service stream.chat.client_v2_rpc.ClientRPC
 */
export interface IClientRPCClient {
    /**
     * Get or create a channel.
     * If the channel does not exist, it will be created. but if it does, it will be returned.
     *
     * @generated from protobuf rpc: GetChannel(stream.chat.client_v2_rpc.GetChannelRequest) returns (stream.chat.client_v2_rpc.GetChannelResponse);
     */
    getChannel$(input: GetChannelRequest, options?: RpcOptions): UnaryCall<GetChannelRequest, GetChannelResponse>;
    /**
     * Query channels.
     * Returns a list of channels that match the query parameters.
     * TODO: rename to QueryChannels
     *
     * @generated from protobuf rpc: QueryChannels(stream.chat.client_v2_rpc.QueryChannelsRequest) returns (stream.chat.client_v2_rpc.QueryChannelsResponse);
     */
    queryChannels(input: QueryChannelsRequest, options?: RpcOptions): UnaryCall<QueryChannelsRequest, QueryChannelsResponse>;
}
/**
 * ClientRPC specific RPC methods.
 * for end-user interactions.
 *
 * @generated from protobuf service stream.chat.client_v2_rpc.ClientRPC
 */
export class ClientRPCClient implements IClientRPCClient, ServiceInfo {
    typeName = ClientRPC.typeName;
    methods = ClientRPC.methods;
    options = ClientRPC.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Get or create a channel.
     * If the channel does not exist, it will be created. but if it does, it will be returned.
     *
     * @generated from protobuf rpc: GetChannel(stream.chat.client_v2_rpc.GetChannelRequest) returns (stream.chat.client_v2_rpc.GetChannelResponse);
     */
    getChannel$(input: GetChannelRequest, options?: RpcOptions): UnaryCall<GetChannelRequest, GetChannelResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetChannelRequest, GetChannelResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Query channels.
     * Returns a list of channels that match the query parameters.
     * TODO: rename to QueryChannels
     *
     * @generated from protobuf rpc: QueryChannels(stream.chat.client_v2_rpc.QueryChannelsRequest) returns (stream.chat.client_v2_rpc.QueryChannelsResponse);
     */
    queryChannels(input: QueryChannelsRequest, options?: RpcOptions): UnaryCall<QueryChannelsRequest, QueryChannelsResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<QueryChannelsRequest, QueryChannelsResponse>("unary", this._transport, method, opt, input);
    }
}
