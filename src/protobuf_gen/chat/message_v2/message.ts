// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none
// @generated from protobuf file "chat/message_v2/message.proto" (package "stream.chat.message_v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
import { ReactionViews } from "../reaction_v2/reaction";
import { User } from "../user_v2/user";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * Message is a chat message that is sent to a channel
 *
 * @generated from protobuf message stream.chat.message_v2.Message
 */
export interface Message {
    /**
     * Unique identifier of the message
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The channel CID of the channel the message was sent to
     *
     * @generated from protobuf field: string channel_cid = 2;
     */
    channelCid: string;
    /**
     * The type of the message
     *
     * @generated from protobuf field: stream.chat.message_v2.MessageType type = 3;
     */
    type: MessageType;
    /**
     * The ID of the user who sent the message
     *
     * @generated from protobuf field: string user_id = 4;
     */
    userId: string;
    /**
     * The text of the message
     *
     * @generated from protobuf field: string text = 5;
     */
    text: string;
    /**
     * The messaging markup language for the message
     *
     * @generated from protobuf field: string mml = 6;
     */
    mml: string;
    /**
     * The HTML content of the message
     *
     * @generated from protobuf field: string html = 7;
     */
    html: string;
    /**
     * A map that contains message text translations into various languages
     * map key is a language name
     * map value is a text translation
     *
     * @generated from protobuf field: map<string, string> i18n = 8 [json_name = "i18n"];
     */
    i18N: {
        [key: string]: string;
    };
    /**
     * JSON object which contains any user data
     *
     * @generated from protobuf field: bytes custom_json = 9;
     */
    customJson: Uint8Array;
    /**
     * @generated from protobuf field: repeated stream.chat.message_v2.MessageAttachment attachments = 10;
     */
    attachments: MessageAttachment[];
    /**
     * The name of a command used in the message
     *
     * @generated from protobuf field: string command_name = 11;
     */
    commandName: string;
    /**
     * The message creation timestamp
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 12;
     */
    createdAt?: Timestamp;
    /**
     * The message update timestamp
     *
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 13;
     */
    updatedAt?: Timestamp;
    /**
     * The message deletion timestamp
     *
     * @generated from protobuf field: google.protobuf.Timestamp deleted_at = 14;
     */
    deletedAt?: Timestamp;
    /**
     * The ID of a parent message, if this message is in a thread
     *
     * @generated from protobuf field: string parent_message_id = 15;
     */
    parentMessageId: string;
    /**
     * Whether to show this message in the channel, if this message is in a thread
     *
     * @generated from protobuf field: bool show_in_channel = 16;
     */
    showInChannel: boolean;
    /**
     * The number of replies to this message
     *
     * @generated from protobuf field: int64 reply_count = 17;
     */
    replyCount: string;
    /**
     * The ID of a message that this message quotes
     *
     * @generated from protobuf field: string quoted_message_id = 18;
     */
    quotedMessageId: string;
    /**
     * Whether the message is silent
     *
     * @generated from protobuf field: bool silent = 19;
     */
    silent: boolean;
    /**
     * Contains message pin info. If empty - message is not pinned
     *
     * @generated from protobuf field: stream.chat.message_v2.MessagePin pinned = 20;
     */
    pinned?: MessagePin;
    /**
     * The user IDs of the users that replied to this message
     *
     * @generated from protobuf field: repeated string thread_participant_user_ids = 21;
     */
    threadParticipantUserIds: string[];
    /**
     * The user IDs of users that were mentioned in this message
     *
     * @generated from protobuf field: repeated string mentioned_user_ids = 22;
     */
    mentionedUserIds: string[];
    /**
     * A map with number of reactions of each type
     * map key is a reaction type
     *
     * @generated from protobuf field: map<string, int64> reaction_counts = 23;
     */
    reactionCounts: {
        [key: string]: string;
    };
    /**
     * A map with sum of reaction scores of each type
     * map key is a reaction type
     *
     * @generated from protobuf field: map<string, int64> reaction_scores = 24;
     */
    reactionScores: {
        [key: string]: string;
    };
}
/**
 * Contains message pin info
 *
 * @generated from protobuf message stream.chat.message_v2.MessagePin
 */
export interface MessagePin {
    /**
     * When the message was pinned
     *
     * @generated from protobuf field: google.protobuf.Timestamp pinned_at = 20;
     */
    pinnedAt?: Timestamp;
    /**
     * When the pin for this message expires
     *
     * @generated from protobuf field: google.protobuf.Timestamp pin_expires_at = 21;
     */
    pinExpiresAt?: Timestamp;
    /**
     * The user ID of the user that pinned this message
     *
     * @generated from protobuf field: string pinned_by_user_id = 22;
     */
    pinnedByUserId: string;
}
/**
 * A view of a message that contains additional info
 *
 * @generated from protobuf message stream.chat.message_v2.MessageView
 */
export interface MessageView {
    /**
     * The message
     *
     * @generated from protobuf field: stream.chat.message_v2.Message message = 1;
     */
    message?: Message;
    /**
     * Message sender object
     *
     * @generated from protobuf field: stream.chat.user_v2.User user = 2;
     */
    user?: User;
    /**
     * Object containing parent message view. Empty if there's no parent message
     *
     * @generated from protobuf field: stream.chat.message_v2.MessageView parent_message = 3;
     */
    parentMessage?: MessageView;
    /**
     * Object containing quoted message. Empty if there's no quoted message
     * MessageView that provided here will not contain quoted message
     *
     * @generated from protobuf field: stream.chat.message_v2.MessageView quoted_message = 4;
     */
    quotedMessage?: MessageView;
    /**
     * List of users who replied to this message
     *
     * @generated from protobuf field: repeated stream.chat.user_v2.User thread_participants = 5;
     */
    threadParticipants: User[];
    /**
     * List of users that were mentioned in this message
     *
     * @generated from protobuf field: repeated stream.chat.user_v2.User mentioned_users = 6;
     */
    mentionedUsers: User[];
    /**
     * A map with 5 latest reactions of each type
     * map key is a reaction type
     *
     * @generated from protobuf field: map<string, stream.chat.reaction_v2.ReactionViews> latest_reactions = 7;
     */
    latestReactions: {
        [key: string]: ReactionViews;
    };
}
/**
 * A collection of messages
 *
 * @generated from protobuf message stream.chat.message_v2.Messages
 */
export interface Messages {
    /**
     * The messages
     *
     * @generated from protobuf field: repeated stream.chat.message_v2.Message messages = 1;
     */
    messages: Message[];
}
/**
 * Attachment that can be added to the message
 *
 * @generated from protobuf message stream.chat.message_v2.MessageAttachment
 */
export interface MessageAttachment {
    /**
     * Type of the attachment. Can be any string.
     * TODO: should we lock this down with enum/oneof to keep in sync with SDKs? We have custom data in messages if someone needs to get creative
     * Examples: image, video, audio, text
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
}
// TODO ===================================================
// ========================================================
// ========================================================
// ========================================================
// ========================================================

/**
 * @generated from protobuf message stream.chat.message_v2.MessageInput
 */
export interface MessageInput {
    /**
     * Unique identifier of the message. The server will generate an ID if it is not set. The server will generate an ID if it is not set
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The channel CID of the channel the message was sent to
     *
     * @generated from protobuf field: string channel_cid = 3;
     */
    channelCid: string;
    /**
     * The text of the message
     *
     * @generated from protobuf field: string text = 4;
     */
    text: string;
    /**
     * The ID of a parent message, if this message is in a thread
     *
     * @generated from protobuf field: string parent_message_id = 5;
     */
    parentMessageId: string;
    /**
     * Whether to show this message in the channel, if this message is in a thread
     *
     * @generated from protobuf field: bool show_in_channel = 6;
     */
    showInChannel: boolean;
    /**
     * The ID of a message that this message quotes
     *
     * @generated from protobuf field: string quoted_message_id = 7;
     */
    quotedMessageId: string;
    /**
     * Whether to show this message in the channel, if this message is in a thread
     *
     * @generated from protobuf field: bool pinned = 8;
     */
    pinned: boolean;
    /**
     * When the message was pinned
     *
     * @generated from protobuf field: google.protobuf.Timestamp pinned_at = 9;
     */
    pinnedAt?: Timestamp;
    /**
     * When the pin for this message expires
     *
     * @generated from protobuf field: google.protobuf.Timestamp pin_expires_at = 10;
     */
    pinExpiresAt?: Timestamp;
    /**
     * Whether the message is silent
     *
     * @generated from protobuf field: bool silent = 11;
     */
    silent: boolean;
}
/**
 * An input to send a message from a client side request
 *
 * @generated from protobuf message stream.chat.message_v2.MessageSendClientSideView
 */
export interface MessageSendClientSideView {
    /**
     * Unique identifier of the message. The server will generate an ID if it is not set. The server will generate an ID if it is not set
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The channel CID of the channel the message was sent to
     *
     * @generated from protobuf field: string channel_cid = 3;
     */
    channelCid: string;
    /**
     * The text of the message
     *
     * @generated from protobuf field: string text = 4;
     */
    text: string;
    /**
     * The ID of a parent message, if this message is in a thread
     *
     * @generated from protobuf field: string parent_message_id = 5;
     */
    parentMessageId: string;
    /**
     * Whether to show this message in the channel, if this message is in a thread
     *
     * @generated from protobuf field: bool show_in_channel = 6;
     */
    showInChannel: boolean;
    /**
     * The ID of a message that this message quotes
     *
     * @generated from protobuf field: string quoted_message_id = 7;
     */
    quotedMessageId: string;
    /**
     * Whether to show this message in the channel, if this message is in a thread
     *
     * @generated from protobuf field: bool pinned = 8;
     */
    pinned: boolean;
    /**
     * When the message was pinned
     *
     * @generated from protobuf field: google.protobuf.Timestamp pinned_at = 9;
     */
    pinnedAt?: Timestamp;
    /**
     * When the pin for this message expires
     *
     * @generated from protobuf field: google.protobuf.Timestamp pin_expires_at = 10;
     */
    pinExpiresAt?: Timestamp;
    /**
     * Whether the message is silent
     *
     * @generated from protobuf field: bool silent = 11;
     */
    silent: boolean;
}
/**
 * An input to send a message from a server side request
 *
 * @generated from protobuf message stream.chat.message_v2.MessageSendServerSideView
 */
export interface MessageSendServerSideView {
    /**
     * The message fields
     *
     * @generated from protobuf field: stream.chat.message_v2.MessageSendClientSideView message = 1;
     */
    message?: MessageSendClientSideView;
    /**
     * The messaging markup language content for the message
     *
     * @generated from protobuf field: string mml = 2;
     */
    mml: string;
    /**
     * The ID of the user who sent the message
     *
     * @generated from protobuf field: string user_id = 3;
     */
    userId: string;
}
/**
 * A request to send a message to a channel
 *
 * @generated from protobuf message stream.chat.message_v2.SendMessageRequest
 */
export interface SendMessageRequest {
    /**
     * @generated from protobuf oneof: message
     */
    message: {
        oneofKind: "clientSideMessage";
        /**
         * @generated from protobuf field: stream.chat.message_v2.MessageSendClientSideView client_side_message = 1;
         */
        clientSideMessage: MessageSendClientSideView;
    } | {
        oneofKind: "serverSideMessage";
        /**
         * @generated from protobuf field: stream.chat.message_v2.MessageSendServerSideView server_side_message = 2;
         */
        serverSideMessage: MessageSendServerSideView;
    } | {
        oneofKind: undefined;
    };
    /**
     * Whether to skip push notifications for this message
     *
     * @generated from protobuf field: bool skip_push = 3;
     */
    skipPush: boolean;
    /**
     * Whether to skip enriching any urls present in this message
     *
     * @generated from protobuf field: bool skip_enrich_url = 4;
     */
    skipEnrichUrl: boolean;
}
/**
 * A response from sending a message
 *
 * @generated from protobuf message stream.chat.message_v2.SendMessageResponse
 */
export interface SendMessageResponse {
    /**
     * The content of the response
     *
     * @generated from protobuf field: stream.chat.message_v2.Message message = 1;
     */
    message?: Message;
}
/**
 * A request to get a message by ID
 *
 * @generated from protobuf message stream.chat.message_v2.GetMessageRequest
 */
export interface GetMessageRequest {
    /**
     * The channel CID of the channel the message is in
     *
     * @generated from protobuf field: string channel_cid = 1;
     */
    channelCid: string;
    /**
     * The ID of the message
     *
     * @generated from protobuf field: string message_id = 2;
     */
    messageId: string;
}
/**
 * A response from getting a message
 *
 * @generated from protobuf message stream.chat.message_v2.GetMessageResponse
 */
export interface GetMessageResponse {
    /**
     * The content of the response
     *
     * @generated from protobuf field: stream.chat.message_v2.Message message = 1;
     */
    message?: Message;
}
/**
 * A request to get many messages by ID
 *
 * @generated from protobuf message stream.chat.message_v2.GetMessagesRequest
 */
export interface GetMessagesRequest {
    /**
     * The ID of the messages
     *
     * @generated from protobuf field: repeated string message_ids = 1;
     */
    messageIds: string[];
    /**
     * The channel CID of the channel the messages are in
     *
     * @generated from protobuf field: string channel_cid = 2;
     */
    channelCid: string;
}
/**
 * A response from getting messages
 *
 * @generated from protobuf message stream.chat.message_v2.GetMessagesResponse
 */
export interface GetMessagesResponse {
    /**
     * The content of the response
     *
     * @generated from protobuf field: stream.chat.message_v2.Messages messages = 1;
     */
    messages?: Messages;
}
/**
 * A request to delete a message by ID
 *
 * @generated from protobuf message stream.chat.message_v2.DeleteMessageRequest
 */
export interface DeleteMessageRequest {
    /**
     * The ID of the message
     *
     * @generated from protobuf field: string message_id = 1;
     */
    messageId: string;
    /**
     * The channel CID of the channel the message is in
     *
     * @generated from protobuf field: string channel_cid = 2;
     */
    channelCid: string;
    /**
     * Whether to hard delete the message
     *
     * @generated from protobuf field: bool hard = 3;
     */
    hard: boolean;
}
/**
 * A response from deleting a message
 *
 * @generated from protobuf message stream.chat.message_v2.DeleteMessageResponse
 */
export interface DeleteMessageResponse {
    /**
     * The content of the response
     *
     * @generated from protobuf field: stream.chat.message_v2.Messages messages = 1;
     */
    messages?: Messages;
}
/**
 * A request to update a message
 *
 * @generated from protobuf message stream.chat.message_v2.UpdateMessageRequest
 */
export interface UpdateMessageRequest {
    /**
     * Whether to skip enriching any urls present in this message
     *
     * @generated from protobuf field: bool skip_enrich_url = 4;
     */
    skipEnrichUrl: boolean;
}
/**
 * A response from updating a message
 *
 * @generated from protobuf message stream.chat.message_v2.UpdateMessageResponse
 */
export interface UpdateMessageResponse {
    /**
     * The content of the response
     *
     * @generated from protobuf field: stream.chat.message_v2.Messages messages = 1;
     */
    messages?: Messages;
}
/**
 * A request to pin a message
 *
 * @generated from protobuf message stream.chat.message_v2.PinMessageRequest
 */
export interface PinMessageRequest {
    /**
     * The ID of the message
     *
     * @generated from protobuf field: string message_id = 1;
     */
    messageId: string;
    /**
     * The channel CID of the channel the message was sent to
     *
     * @generated from protobuf field: string channel_cid = 2;
     */
    channelCid: string;
    /**
     * When the message was pinned. If empty, the server will populate this field
     *
     * @generated from protobuf field: google.protobuf.Timestamp pinned_at = 3;
     */
    pinnedAt?: Timestamp;
    /**
     * When the pin for this message expires
     *
     * @generated from protobuf field: google.protobuf.Timestamp pin_expires_at = 4;
     */
    pinExpiresAt?: Timestamp;
}
/**
 * A response from pinning a message
 *
 * @generated from protobuf message stream.chat.message_v2.PinMessageResponse
 */
export interface PinMessageResponse {
    /**
     * The content of the response
     *
     * @generated from protobuf field: stream.chat.message_v2.Messages messages = 1;
     */
    messages?: Messages;
}
/**
 * A request to unpin a message
 *
 * @generated from protobuf message stream.chat.message_v2.UnpinMessageRequest
 */
export interface UnpinMessageRequest {
    /**
     * The ID of the message
     *
     * @generated from protobuf field: string message_id = 1;
     */
    messageId: string;
    /**
     * The channel CID of the channel the message was sent to
     *
     * @generated from protobuf field: string channel_cid = 2;
     */
    channelCid: string;
}
/**
 * A response from unpinning a message
 *
 * @generated from protobuf message stream.chat.message_v2.UnpinMessageResponse
 */
export interface UnpinMessageResponse {
    /**
     * The content of the response
     *
     * @generated from protobuf field: stream.chat.message_v2.Messages messages = 1;
     */
    messages?: Messages;
}
/**
 * The type of the message
 *
 * @generated from protobuf enum stream.chat.message_v2.MessageType
 */
export enum MessageType {
    /**
     * @generated from protobuf enum value: MESSAGE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * A regular message
     *
     * @generated from protobuf enum value: MESSAGE_TYPE_REGULAR = 1;
     */
    REGULAR = 1,
    /**
     * A temporary message which is only delivered to one user
     *
     * @generated from protobuf enum value: MESSAGE_TYPE_EPHEMERAL = 2;
     */
    EPHEMERAL = 2,
    /**
     * An error message which occurs as the result of a failed command
     *
     * @generated from protobuf enum value: MESSAGE_TYPE_ERROR = 3;
     */
    ERROR = 3,
    /**
     * A reply in a thread
     *
     * @generated from protobuf enum value: MESSAGE_TYPE_REPLY = 4;
     */
    REPLY = 4,
    /**
     * A message generated by a system event
     *
     * @generated from protobuf enum value: MESSAGE_TYPE_SYSTEM = 5;
     */
    SYSTEM = 5,
    /**
     * A soft deleted message
     *
     * @generated from protobuf enum value: MESSAGE_TYPE_DELETED = 6;
     */
    DELETED = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType$<Message> {
    constructor() {
        super("stream.chat.message_v2.Message", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["stream.chat.message_v2.MessageType", MessageType, "MESSAGE_TYPE_"] },
            { no: 4, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "mml", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "html", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "i18n", kind: "map", jsonName: "i18n", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 9, name: "custom_json", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "attachments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MessageAttachment },
            { no: 11, name: "command_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 13, name: "updated_at", kind: "message", T: () => Timestamp },
            { no: 14, name: "deleted_at", kind: "message", T: () => Timestamp },
            { no: 15, name: "parent_message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "show_in_channel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "reply_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 18, name: "quoted_message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "silent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "pinned", kind: "message", T: () => MessagePin },
            { no: 21, name: "thread_participant_user_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "mentioned_user_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "reaction_counts", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 24, name: "reaction_scores", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = { id: "", channelCid: "", type: 0, userId: "", text: "", mml: "", html: "", i18N: {}, customJson: new Uint8Array(0), attachments: [], commandName: "", parentMessageId: "", showInChannel: false, replyCount: "0", quotedMessageId: "", silent: false, threadParticipantUserIds: [], mentionedUserIds: [], reactionCounts: {}, reactionScores: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string channel_cid */ 2:
                    message.channelCid = reader.string();
                    break;
                case /* stream.chat.message_v2.MessageType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* string user_id */ 4:
                    message.userId = reader.string();
                    break;
                case /* string text */ 5:
                    message.text = reader.string();
                    break;
                case /* string mml */ 6:
                    message.mml = reader.string();
                    break;
                case /* string html */ 7:
                    message.html = reader.string();
                    break;
                case /* map<string, string> i18n = 8 [json_name = "i18n"];*/ 8:
                    this.binaryReadMap8(message.i18N, reader, options);
                    break;
                case /* bytes custom_json */ 9:
                    message.customJson = reader.bytes();
                    break;
                case /* repeated stream.chat.message_v2.MessageAttachment attachments */ 10:
                    message.attachments.push(MessageAttachment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string command_name */ 11:
                    message.commandName = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 12:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 13:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* google.protobuf.Timestamp deleted_at */ 14:
                    message.deletedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                case /* string parent_message_id */ 15:
                    message.parentMessageId = reader.string();
                    break;
                case /* bool show_in_channel */ 16:
                    message.showInChannel = reader.bool();
                    break;
                case /* int64 reply_count */ 17:
                    message.replyCount = reader.int64().toString();
                    break;
                case /* string quoted_message_id */ 18:
                    message.quotedMessageId = reader.string();
                    break;
                case /* bool silent */ 19:
                    message.silent = reader.bool();
                    break;
                case /* stream.chat.message_v2.MessagePin pinned */ 20:
                    message.pinned = MessagePin.internalBinaryRead(reader, reader.uint32(), options, message.pinned);
                    break;
                case /* repeated string thread_participant_user_ids */ 21:
                    message.threadParticipantUserIds.push(reader.string());
                    break;
                case /* repeated string mentioned_user_ids */ 22:
                    message.mentionedUserIds.push(reader.string());
                    break;
                case /* map<string, int64> reaction_counts */ 23:
                    this.binaryReadMap23(message.reactionCounts, reader, options);
                    break;
                case /* map<string, int64> reaction_scores */ 24:
                    this.binaryReadMap24(message.reactionScores, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: Message["i18N"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Message["i18N"] | undefined, val: Message["i18N"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.chat.message_v2.Message.i18n");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap23(map: Message["reactionCounts"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Message["reactionCounts"] | undefined, val: Message["reactionCounts"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.chat.message_v2.Message.reaction_counts");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    private binaryReadMap24(map: Message["reactionScores"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Message["reactionScores"] | undefined, val: Message["reactionScores"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.chat.message_v2.Message.reaction_scores");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string channel_cid = 2; */
        if (message.channelCid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelCid);
        /* stream.chat.message_v2.MessageType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* string user_id = 4; */
        if (message.userId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.userId);
        /* string text = 5; */
        if (message.text !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.text);
        /* string mml = 6; */
        if (message.mml !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.mml);
        /* string html = 7; */
        if (message.html !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.html);
        /* map<string, string> i18n = 8 [json_name = "i18n"]; */
        for (let k of Object.keys(message.i18N))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.i18N[k]).join();
        /* bytes custom_json = 9; */
        if (message.customJson.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.customJson);
        /* repeated stream.chat.message_v2.MessageAttachment attachments = 10; */
        for (let i = 0; i < message.attachments.length; i++)
            MessageAttachment.internalBinaryWrite(message.attachments[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* string command_name = 11; */
        if (message.commandName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.commandName);
        /* google.protobuf.Timestamp created_at = 12; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 13; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp deleted_at = 14; */
        if (message.deletedAt)
            Timestamp.internalBinaryWrite(message.deletedAt, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string parent_message_id = 15; */
        if (message.parentMessageId !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.parentMessageId);
        /* bool show_in_channel = 16; */
        if (message.showInChannel !== false)
            writer.tag(16, WireType.Varint).bool(message.showInChannel);
        /* int64 reply_count = 17; */
        if (message.replyCount !== "0")
            writer.tag(17, WireType.Varint).int64(message.replyCount);
        /* string quoted_message_id = 18; */
        if (message.quotedMessageId !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.quotedMessageId);
        /* bool silent = 19; */
        if (message.silent !== false)
            writer.tag(19, WireType.Varint).bool(message.silent);
        /* stream.chat.message_v2.MessagePin pinned = 20; */
        if (message.pinned)
            MessagePin.internalBinaryWrite(message.pinned, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* repeated string thread_participant_user_ids = 21; */
        for (let i = 0; i < message.threadParticipantUserIds.length; i++)
            writer.tag(21, WireType.LengthDelimited).string(message.threadParticipantUserIds[i]);
        /* repeated string mentioned_user_ids = 22; */
        for (let i = 0; i < message.mentionedUserIds.length; i++)
            writer.tag(22, WireType.LengthDelimited).string(message.mentionedUserIds[i]);
        /* map<string, int64> reaction_counts = 23; */
        for (let k of Object.keys(message.reactionCounts))
            writer.tag(23, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.reactionCounts[k]).join();
        /* map<string, int64> reaction_scores = 24; */
        for (let k of Object.keys(message.reactionScores))
            writer.tag(24, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.reactionScores[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.Message
 */
export const Message = new Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessagePin$Type extends MessageType$<MessagePin> {
    constructor() {
        super("stream.chat.message_v2.MessagePin", [
            { no: 20, name: "pinned_at", kind: "message", T: () => Timestamp },
            { no: 21, name: "pin_expires_at", kind: "message", T: () => Timestamp },
            { no: 22, name: "pinned_by_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessagePin>): MessagePin {
        const message = { pinnedByUserId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessagePin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessagePin): MessagePin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp pinned_at */ 20:
                    message.pinnedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.pinnedAt);
                    break;
                case /* google.protobuf.Timestamp pin_expires_at */ 21:
                    message.pinExpiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.pinExpiresAt);
                    break;
                case /* string pinned_by_user_id */ 22:
                    message.pinnedByUserId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessagePin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp pinned_at = 20; */
        if (message.pinnedAt)
            Timestamp.internalBinaryWrite(message.pinnedAt, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp pin_expires_at = 21; */
        if (message.pinExpiresAt)
            Timestamp.internalBinaryWrite(message.pinExpiresAt, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* string pinned_by_user_id = 22; */
        if (message.pinnedByUserId !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.pinnedByUserId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.MessagePin
 */
export const MessagePin = new MessagePin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageView$Type extends MessageType$<MessageView> {
    constructor() {
        super("stream.chat.message_v2.MessageView", [
            { no: 1, name: "message", kind: "message", T: () => Message },
            { no: 2, name: "user", kind: "message", T: () => User },
            { no: 3, name: "parent_message", kind: "message", T: () => MessageView },
            { no: 4, name: "quoted_message", kind: "message", T: () => MessageView },
            { no: 5, name: "thread_participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => User },
            { no: 6, name: "mentioned_users", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => User },
            { no: 7, name: "latest_reactions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ReactionViews } }
        ]);
    }
    create(value?: PartialMessage<MessageView>): MessageView {
        const message = { threadParticipants: [], mentionedUsers: [], latestReactions: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageView): MessageView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.Message message */ 1:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                case /* stream.chat.user_v2.User user */ 2:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* stream.chat.message_v2.MessageView parent_message */ 3:
                    message.parentMessage = MessageView.internalBinaryRead(reader, reader.uint32(), options, message.parentMessage);
                    break;
                case /* stream.chat.message_v2.MessageView quoted_message */ 4:
                    message.quotedMessage = MessageView.internalBinaryRead(reader, reader.uint32(), options, message.quotedMessage);
                    break;
                case /* repeated stream.chat.user_v2.User thread_participants */ 5:
                    message.threadParticipants.push(User.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated stream.chat.user_v2.User mentioned_users */ 6:
                    message.mentionedUsers.push(User.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, stream.chat.reaction_v2.ReactionViews> latest_reactions */ 7:
                    this.binaryReadMap7(message.latestReactions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: MessageView["latestReactions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MessageView["latestReactions"] | undefined, val: MessageView["latestReactions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ReactionViews.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field stream.chat.message_v2.MessageView.latest_reactions");
            }
        }
        map[key ?? ""] = val ?? ReactionViews.create();
    }
    internalBinaryWrite(message: MessageView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.Message message = 1; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.user_v2.User user = 2; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.message_v2.MessageView parent_message = 3; */
        if (message.parentMessage)
            MessageView.internalBinaryWrite(message.parentMessage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.message_v2.MessageView quoted_message = 4; */
        if (message.quotedMessage)
            MessageView.internalBinaryWrite(message.quotedMessage, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.chat.user_v2.User thread_participants = 5; */
        for (let i = 0; i < message.threadParticipants.length; i++)
            User.internalBinaryWrite(message.threadParticipants[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.chat.user_v2.User mentioned_users = 6; */
        for (let i = 0; i < message.mentionedUsers.length; i++)
            User.internalBinaryWrite(message.mentionedUsers[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* map<string, stream.chat.reaction_v2.ReactionViews> latest_reactions = 7; */
        for (let k of Object.keys(message.latestReactions)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ReactionViews.internalBinaryWrite(message.latestReactions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.MessageView
 */
export const MessageView = new MessageView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Messages$Type extends MessageType$<Messages> {
    constructor() {
        super("stream.chat.message_v2.Messages", [
            { no: 1, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Message }
        ]);
    }
    create(value?: PartialMessage<Messages>): Messages {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Messages>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Messages): Messages {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.chat.message_v2.Message messages */ 1:
                    message.messages.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Messages, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.chat.message_v2.Message messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            Message.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.Messages
 */
export const Messages = new Messages$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageAttachment$Type extends MessageType$<MessageAttachment> {
    constructor() {
        super("stream.chat.message_v2.MessageAttachment", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageAttachment>): MessageAttachment {
        const message = { type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageAttachment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageAttachment): MessageAttachment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageAttachment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.MessageAttachment
 */
export const MessageAttachment = new MessageAttachment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageInput$Type extends MessageType$<MessageInput> {
    constructor() {
        super("stream.chat.message_v2.MessageInput", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "channel_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parent_message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "show_in_channel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "quoted_message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "pinned", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "pinned_at", kind: "message", T: () => Timestamp },
            { no: 10, name: "pin_expires_at", kind: "message", T: () => Timestamp },
            { no: 11, name: "silent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MessageInput>): MessageInput {
        const message = { id: "", channelCid: "", text: "", parentMessageId: "", showInChannel: false, quotedMessageId: "", pinned: false, silent: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageInput): MessageInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string channel_cid */ 3:
                    message.channelCid = reader.string();
                    break;
                case /* string text */ 4:
                    message.text = reader.string();
                    break;
                case /* string parent_message_id */ 5:
                    message.parentMessageId = reader.string();
                    break;
                case /* bool show_in_channel */ 6:
                    message.showInChannel = reader.bool();
                    break;
                case /* string quoted_message_id */ 7:
                    message.quotedMessageId = reader.string();
                    break;
                case /* bool pinned */ 8:
                    message.pinned = reader.bool();
                    break;
                case /* google.protobuf.Timestamp pinned_at */ 9:
                    message.pinnedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.pinnedAt);
                    break;
                case /* google.protobuf.Timestamp pin_expires_at */ 10:
                    message.pinExpiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.pinExpiresAt);
                    break;
                case /* bool silent */ 11:
                    message.silent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string channel_cid = 3; */
        if (message.channelCid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.channelCid);
        /* string text = 4; */
        if (message.text !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.text);
        /* string parent_message_id = 5; */
        if (message.parentMessageId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.parentMessageId);
        /* bool show_in_channel = 6; */
        if (message.showInChannel !== false)
            writer.tag(6, WireType.Varint).bool(message.showInChannel);
        /* string quoted_message_id = 7; */
        if (message.quotedMessageId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.quotedMessageId);
        /* bool pinned = 8; */
        if (message.pinned !== false)
            writer.tag(8, WireType.Varint).bool(message.pinned);
        /* google.protobuf.Timestamp pinned_at = 9; */
        if (message.pinnedAt)
            Timestamp.internalBinaryWrite(message.pinnedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp pin_expires_at = 10; */
        if (message.pinExpiresAt)
            Timestamp.internalBinaryWrite(message.pinExpiresAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool silent = 11; */
        if (message.silent !== false)
            writer.tag(11, WireType.Varint).bool(message.silent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.MessageInput
 */
export const MessageInput = new MessageInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageSendClientSideView$Type extends MessageType$<MessageSendClientSideView> {
    constructor() {
        super("stream.chat.message_v2.MessageSendClientSideView", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "channel_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parent_message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "show_in_channel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "quoted_message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "pinned", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "pinned_at", kind: "message", T: () => Timestamp },
            { no: 10, name: "pin_expires_at", kind: "message", T: () => Timestamp },
            { no: 11, name: "silent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MessageSendClientSideView>): MessageSendClientSideView {
        const message = { id: "", channelCid: "", text: "", parentMessageId: "", showInChannel: false, quotedMessageId: "", pinned: false, silent: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageSendClientSideView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageSendClientSideView): MessageSendClientSideView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string channel_cid */ 3:
                    message.channelCid = reader.string();
                    break;
                case /* string text */ 4:
                    message.text = reader.string();
                    break;
                case /* string parent_message_id */ 5:
                    message.parentMessageId = reader.string();
                    break;
                case /* bool show_in_channel */ 6:
                    message.showInChannel = reader.bool();
                    break;
                case /* string quoted_message_id */ 7:
                    message.quotedMessageId = reader.string();
                    break;
                case /* bool pinned */ 8:
                    message.pinned = reader.bool();
                    break;
                case /* google.protobuf.Timestamp pinned_at */ 9:
                    message.pinnedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.pinnedAt);
                    break;
                case /* google.protobuf.Timestamp pin_expires_at */ 10:
                    message.pinExpiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.pinExpiresAt);
                    break;
                case /* bool silent */ 11:
                    message.silent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageSendClientSideView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string channel_cid = 3; */
        if (message.channelCid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.channelCid);
        /* string text = 4; */
        if (message.text !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.text);
        /* string parent_message_id = 5; */
        if (message.parentMessageId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.parentMessageId);
        /* bool show_in_channel = 6; */
        if (message.showInChannel !== false)
            writer.tag(6, WireType.Varint).bool(message.showInChannel);
        /* string quoted_message_id = 7; */
        if (message.quotedMessageId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.quotedMessageId);
        /* bool pinned = 8; */
        if (message.pinned !== false)
            writer.tag(8, WireType.Varint).bool(message.pinned);
        /* google.protobuf.Timestamp pinned_at = 9; */
        if (message.pinnedAt)
            Timestamp.internalBinaryWrite(message.pinnedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp pin_expires_at = 10; */
        if (message.pinExpiresAt)
            Timestamp.internalBinaryWrite(message.pinExpiresAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool silent = 11; */
        if (message.silent !== false)
            writer.tag(11, WireType.Varint).bool(message.silent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.MessageSendClientSideView
 */
export const MessageSendClientSideView = new MessageSendClientSideView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageSendServerSideView$Type extends MessageType$<MessageSendServerSideView> {
    constructor() {
        super("stream.chat.message_v2.MessageSendServerSideView", [
            { no: 1, name: "message", kind: "message", T: () => MessageSendClientSideView },
            { no: 2, name: "mml", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageSendServerSideView>): MessageSendServerSideView {
        const message = { mml: "", userId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageSendServerSideView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageSendServerSideView): MessageSendServerSideView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.MessageSendClientSideView message */ 1:
                    message.message = MessageSendClientSideView.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                case /* string mml */ 2:
                    message.mml = reader.string();
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageSendServerSideView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.MessageSendClientSideView message = 1; */
        if (message.message)
            MessageSendClientSideView.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string mml = 2; */
        if (message.mml !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mml);
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.MessageSendServerSideView
 */
export const MessageSendServerSideView = new MessageSendServerSideView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageRequest$Type extends MessageType$<SendMessageRequest> {
    constructor() {
        super("stream.chat.message_v2.SendMessageRequest", [
            { no: 1, name: "client_side_message", kind: "message", oneof: "message", T: () => MessageSendClientSideView },
            { no: 2, name: "server_side_message", kind: "message", oneof: "message", T: () => MessageSendServerSideView },
            { no: 3, name: "skip_push", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "skip_enrich_url", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SendMessageRequest>): SendMessageRequest {
        const message = { message: { oneofKind: undefined }, skipPush: false, skipEnrichUrl: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageRequest): SendMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.MessageSendClientSideView client_side_message */ 1:
                    message.message = {
                        oneofKind: "clientSideMessage",
                        clientSideMessage: MessageSendClientSideView.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).clientSideMessage)
                    };
                    break;
                case /* stream.chat.message_v2.MessageSendServerSideView server_side_message */ 2:
                    message.message = {
                        oneofKind: "serverSideMessage",
                        serverSideMessage: MessageSendServerSideView.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).serverSideMessage)
                    };
                    break;
                case /* bool skip_push */ 3:
                    message.skipPush = reader.bool();
                    break;
                case /* bool skip_enrich_url */ 4:
                    message.skipEnrichUrl = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.MessageSendClientSideView client_side_message = 1; */
        if (message.message.oneofKind === "clientSideMessage")
            MessageSendClientSideView.internalBinaryWrite(message.message.clientSideMessage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.message_v2.MessageSendServerSideView server_side_message = 2; */
        if (message.message.oneofKind === "serverSideMessage")
            MessageSendServerSideView.internalBinaryWrite(message.message.serverSideMessage, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool skip_push = 3; */
        if (message.skipPush !== false)
            writer.tag(3, WireType.Varint).bool(message.skipPush);
        /* bool skip_enrich_url = 4; */
        if (message.skipEnrichUrl !== false)
            writer.tag(4, WireType.Varint).bool(message.skipEnrichUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.SendMessageRequest
 */
export const SendMessageRequest = new SendMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageResponse$Type extends MessageType$<SendMessageResponse> {
    constructor() {
        super("stream.chat.message_v2.SendMessageResponse", [
            { no: 1, name: "message", kind: "message", T: () => Message }
        ]);
    }
    create(value?: PartialMessage<SendMessageResponse>): SendMessageResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageResponse): SendMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.Message message */ 1:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.Message message = 1; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.SendMessageResponse
 */
export const SendMessageResponse = new SendMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMessageRequest$Type extends MessageType$<GetMessageRequest> {
    constructor() {
        super("stream.chat.message_v2.GetMessageRequest", [
            { no: 1, name: "channel_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMessageRequest>): GetMessageRequest {
        const message = { channelCid: "", messageId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMessageRequest): GetMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string channel_cid */ 1:
                    message.channelCid = reader.string();
                    break;
                case /* string message_id */ 2:
                    message.messageId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string channel_cid = 1; */
        if (message.channelCid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.channelCid);
        /* string message_id = 2; */
        if (message.messageId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.messageId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.GetMessageRequest
 */
export const GetMessageRequest = new GetMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMessageResponse$Type extends MessageType$<GetMessageResponse> {
    constructor() {
        super("stream.chat.message_v2.GetMessageResponse", [
            { no: 1, name: "message", kind: "message", T: () => Message }
        ]);
    }
    create(value?: PartialMessage<GetMessageResponse>): GetMessageResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMessageResponse): GetMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.Message message */ 1:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.Message message = 1; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.GetMessageResponse
 */
export const GetMessageResponse = new GetMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMessagesRequest$Type extends MessageType$<GetMessagesRequest> {
    constructor() {
        super("stream.chat.message_v2.GetMessagesRequest", [
            { no: 1, name: "message_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMessagesRequest>): GetMessagesRequest {
        const message = { messageIds: [], channelCid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMessagesRequest): GetMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string message_ids */ 1:
                    message.messageIds.push(reader.string());
                    break;
                case /* string channel_cid */ 2:
                    message.channelCid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string message_ids = 1; */
        for (let i = 0; i < message.messageIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.messageIds[i]);
        /* string channel_cid = 2; */
        if (message.channelCid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelCid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.GetMessagesRequest
 */
export const GetMessagesRequest = new GetMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMessagesResponse$Type extends MessageType$<GetMessagesResponse> {
    constructor() {
        super("stream.chat.message_v2.GetMessagesResponse", [
            { no: 1, name: "messages", kind: "message", T: () => Messages }
        ]);
    }
    create(value?: PartialMessage<GetMessagesResponse>): GetMessagesResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMessagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMessagesResponse): GetMessagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.Messages messages */ 1:
                    message.messages = Messages.internalBinaryRead(reader, reader.uint32(), options, message.messages);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMessagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.Messages messages = 1; */
        if (message.messages)
            Messages.internalBinaryWrite(message.messages, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.GetMessagesResponse
 */
export const GetMessagesResponse = new GetMessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMessageRequest$Type extends MessageType$<DeleteMessageRequest> {
    constructor() {
        super("stream.chat.message_v2.DeleteMessageRequest", [
            { no: 1, name: "message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hard", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteMessageRequest>): DeleteMessageRequest {
        const message = { messageId: "", channelCid: "", hard: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMessageRequest): DeleteMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_id */ 1:
                    message.messageId = reader.string();
                    break;
                case /* string channel_cid */ 2:
                    message.channelCid = reader.string();
                    break;
                case /* bool hard */ 3:
                    message.hard = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_id = 1; */
        if (message.messageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* string channel_cid = 2; */
        if (message.channelCid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelCid);
        /* bool hard = 3; */
        if (message.hard !== false)
            writer.tag(3, WireType.Varint).bool(message.hard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.DeleteMessageRequest
 */
export const DeleteMessageRequest = new DeleteMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMessageResponse$Type extends MessageType$<DeleteMessageResponse> {
    constructor() {
        super("stream.chat.message_v2.DeleteMessageResponse", [
            { no: 1, name: "messages", kind: "message", T: () => Messages }
        ]);
    }
    create(value?: PartialMessage<DeleteMessageResponse>): DeleteMessageResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMessageResponse): DeleteMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.Messages messages */ 1:
                    message.messages = Messages.internalBinaryRead(reader, reader.uint32(), options, message.messages);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.Messages messages = 1; */
        if (message.messages)
            Messages.internalBinaryWrite(message.messages, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.DeleteMessageResponse
 */
export const DeleteMessageResponse = new DeleteMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMessageRequest$Type extends MessageType$<UpdateMessageRequest> {
    constructor() {
        super("stream.chat.message_v2.UpdateMessageRequest", [
            { no: 4, name: "skip_enrich_url", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateMessageRequest>): UpdateMessageRequest {
        const message = { skipEnrichUrl: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMessageRequest): UpdateMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_enrich_url */ 4:
                    message.skipEnrichUrl = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool skip_enrich_url = 4; */
        if (message.skipEnrichUrl !== false)
            writer.tag(4, WireType.Varint).bool(message.skipEnrichUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.UpdateMessageRequest
 */
export const UpdateMessageRequest = new UpdateMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMessageResponse$Type extends MessageType$<UpdateMessageResponse> {
    constructor() {
        super("stream.chat.message_v2.UpdateMessageResponse", [
            { no: 1, name: "messages", kind: "message", T: () => Messages }
        ]);
    }
    create(value?: PartialMessage<UpdateMessageResponse>): UpdateMessageResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMessageResponse): UpdateMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.Messages messages */ 1:
                    message.messages = Messages.internalBinaryRead(reader, reader.uint32(), options, message.messages);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.Messages messages = 1; */
        if (message.messages)
            Messages.internalBinaryWrite(message.messages, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.UpdateMessageResponse
 */
export const UpdateMessageResponse = new UpdateMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PinMessageRequest$Type extends MessageType$<PinMessageRequest> {
    constructor() {
        super("stream.chat.message_v2.PinMessageRequest", [
            { no: 1, name: "message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pinned_at", kind: "message", T: () => Timestamp },
            { no: 4, name: "pin_expires_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<PinMessageRequest>): PinMessageRequest {
        const message = { messageId: "", channelCid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PinMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PinMessageRequest): PinMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_id */ 1:
                    message.messageId = reader.string();
                    break;
                case /* string channel_cid */ 2:
                    message.channelCid = reader.string();
                    break;
                case /* google.protobuf.Timestamp pinned_at */ 3:
                    message.pinnedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.pinnedAt);
                    break;
                case /* google.protobuf.Timestamp pin_expires_at */ 4:
                    message.pinExpiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.pinExpiresAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PinMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_id = 1; */
        if (message.messageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* string channel_cid = 2; */
        if (message.channelCid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelCid);
        /* google.protobuf.Timestamp pinned_at = 3; */
        if (message.pinnedAt)
            Timestamp.internalBinaryWrite(message.pinnedAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp pin_expires_at = 4; */
        if (message.pinExpiresAt)
            Timestamp.internalBinaryWrite(message.pinExpiresAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.PinMessageRequest
 */
export const PinMessageRequest = new PinMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PinMessageResponse$Type extends MessageType$<PinMessageResponse> {
    constructor() {
        super("stream.chat.message_v2.PinMessageResponse", [
            { no: 1, name: "messages", kind: "message", T: () => Messages }
        ]);
    }
    create(value?: PartialMessage<PinMessageResponse>): PinMessageResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PinMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PinMessageResponse): PinMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.Messages messages */ 1:
                    message.messages = Messages.internalBinaryRead(reader, reader.uint32(), options, message.messages);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PinMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.Messages messages = 1; */
        if (message.messages)
            Messages.internalBinaryWrite(message.messages, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.PinMessageResponse
 */
export const PinMessageResponse = new PinMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnpinMessageRequest$Type extends MessageType$<UnpinMessageRequest> {
    constructor() {
        super("stream.chat.message_v2.UnpinMessageRequest", [
            { no: 1, name: "message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_cid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UnpinMessageRequest>): UnpinMessageRequest {
        const message = { messageId: "", channelCid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnpinMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnpinMessageRequest): UnpinMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_id */ 1:
                    message.messageId = reader.string();
                    break;
                case /* string channel_cid */ 2:
                    message.channelCid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnpinMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_id = 1; */
        if (message.messageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* string channel_cid = 2; */
        if (message.channelCid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelCid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.UnpinMessageRequest
 */
export const UnpinMessageRequest = new UnpinMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnpinMessageResponse$Type extends MessageType$<UnpinMessageResponse> {
    constructor() {
        super("stream.chat.message_v2.UnpinMessageResponse", [
            { no: 1, name: "messages", kind: "message", T: () => Messages }
        ]);
    }
    create(value?: PartialMessage<UnpinMessageResponse>): UnpinMessageResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnpinMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnpinMessageResponse): UnpinMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.message_v2.Messages messages */ 1:
                    message.messages = Messages.internalBinaryRead(reader, reader.uint32(), options, message.messages);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnpinMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.message_v2.Messages messages = 1; */
        if (message.messages)
            Messages.internalBinaryWrite(message.messages, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.message_v2.UnpinMessageResponse
 */
export const UnpinMessageResponse = new UnpinMessageResponse$Type();
