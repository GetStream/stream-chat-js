// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none
// @generated from protobuf file "chat/v2/user.proto" (package "stream.chat.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BoolValue } from "../../google/protobuf/wrappers";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * Chat user model
 *
 * @generated from protobuf message stream.chat.v2.User
 */
export interface User {
    /**
     * Unique identifier of the User.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * User's role in the permission system.
     *
     * @generated from protobuf field: string role = 2;
     */
    role: string;
    /**
     * Contains information about user's online status.
     *
     * @generated from protobuf field: stream.chat.v2.UserOnlineStatus online_status = 3;
     */
    onlineStatus?: UserOnlineStatus;
    /**
     * Contains information about user's ban status.
     *
     * @generated from protobuf field: stream.chat.v2.UserBanStatus ban = 4;
     */
    ban?: UserBanStatus;
    /**
     * List of teams user is a part of.
     *
     * @generated from protobuf field: repeated string teams = 5;
     */
    teams: string[];
    /**
     * Preferred language of a user.
     *
     * @generated from protobuf field: string language = 6;
     */
    language: string;
    /**
     * custom is a JSON object which contains any user data.
     * in JSON encoded messages it will be represented as base64 encoded bytes
     *
     * @generated from protobuf field: bytes custom_json = 7;
     */
    customJson: Uint8Array;
    /**
     * Date of creation of the user.
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 8;
     */
    createdAt?: Timestamp;
    /**
     * Date of last update of user's data.
     *
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 9;
     */
    updatedAt?: Timestamp;
    /**
     * Date of deletion of the user.
     *
     * @generated from protobuf field: google.protobuf.Timestamp deleted_at = 10;
     */
    deletedAt?: Timestamp;
    /**
     * Date of deactivation of the user.
     *
     * @generated from protobuf field: google.protobuf.Timestamp deactivated_at = 11;
     */
    deactivatedAt?: Timestamp;
}
/**
 * Contains information about user's online status.
 *
 * @generated from protobuf message stream.chat.v2.UserOnlineStatus
 */
export interface UserOnlineStatus {
    /**
     * Whether the user is online.
     *
     * @generated from protobuf field: bool online = 1;
     */
    online: boolean;
    /**
     * Timestamp of the last activity.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_active_at = 2;
     */
    lastActiveAt?: Timestamp;
    /**
     * Invisibility condition of the user.
     * Setting this field to true will cause the user to be marked as offline
     * This field is not visible to other users
     *
     * @generated from protobuf field: google.protobuf.BoolValue invisible = 3;
     */
    invisible?: BoolValue;
}
/**
 * Contains information about user's ban status.
 *
 * @generated from protobuf message stream.chat.v2.UserBanStatus
 */
export interface UserBanStatus {
    /**
     * Whether the user is banned.
     *
     * @generated from protobuf field: bool banned = 1;
     */
    banned: boolean;
    /**
     * Time when the user will be unbanned.
     *
     * @generated from protobuf field: google.protobuf.Timestamp ban_expires_at = 2;
     */
    banExpiresAt?: Timestamp;
}
// TODO ===================================================
// ========================================================
// ========================================================
// ========================================================
// ========================================================

/**
 * @generated from protobuf message stream.chat.v2.UserOwnView
 */
export interface UserOwnView {
    /**
     * @generated from protobuf field: stream.chat.v2.User user = 1;
     */
    user?: User;
    /**
     * @generated from protobuf field: stream.chat.v2.UserPushNotificationsSettings push_settings = 2;
     */
    pushSettings?: UserPushNotificationsSettings;
    /**
     * @generated from protobuf field: stream.chat.v2.UserUnreadStatus unread = 3;
     */
    unread?: UserUnreadStatus;
}
/**
 * @generated from protobuf message stream.chat.v2.UserSettings
 */
export interface UserSettings {
    /**
     * @generated from protobuf field: stream.chat.v2.UserPushNotificationsSettings push = 2;
     */
    push?: UserPushNotificationsSettings;
}
/**
 * @generated from protobuf message stream.chat.v2.UserPushNotificationsSettings
 */
export interface UserPushNotificationsSettings {
    /**
     * @generated from protobuf field: bool disabled = 1;
     */
    disabled: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp disabled_until = 2;
     */
    disabledUntil?: Timestamp;
    /**
     * @generated from protobuf field: repeated stream.chat.v2.UserPushDevice devices = 3;
     */
    devices: UserPushDevice[];
}
/**
 * @generated from protobuf message stream.chat.v2.UserPushDevice
 */
export interface UserPushDevice {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: stream.chat.v2.PushProvider push_provider = 2;
     */
    pushProvider: PushProvider;
    /**
     * @generated from protobuf field: string push_provider_name = 3;
     */
    pushProviderName: string;
}
/**
 * @generated from protobuf message stream.chat.v2.UserUnreadStatus
 */
export interface UserUnreadStatus {
    /**
     * @generated from protobuf field: int64 unread_message_count = 1;
     */
    unreadMessageCount: string;
    /**
     * @generated from protobuf field: int64 unread_channels_count = 2;
     */
    unreadChannelsCount: string;
}
/**
 * TODO: Q/A Do we need these data below?
 *
 *
 * @generated from protobuf message stream.chat.v2.UserLatest
 */
export interface UserLatest {
}
/**
 * @generated from protobuf message stream.chat.v2.UserMute
 */
export interface UserMute {
}
/**
 * @generated from protobuf message stream.chat.v2.UserChannelMute
 */
export interface UserChannelMute {
}
/**
 * @generated from protobuf enum stream.chat.v2.PushProvider
 */
export enum PushProvider {
    /**
     * @generated from protobuf enum value: PUSH_PROVIDER_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PUSH_PROVIDER_FIREBASE = 1;
     */
    FIREBASE = 1,
    /**
     * @generated from protobuf enum value: PUSH_PROVIDER_APN = 2;
     */
    APN = 2,
    /**
     * @generated from protobuf enum value: PUSH_PROVIDER_HUAWEI = 3;
     */
    HUAWEI = 3,
    /**
     * @generated from protobuf enum value: PUSH_PROVIDER_XIAOMI = 4;
     */
    XIAOMI = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("stream.chat.v2.User", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "online_status", kind: "message", T: () => UserOnlineStatus },
            { no: 4, name: "ban", kind: "message", T: () => UserBanStatus },
            { no: 5, name: "teams", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "custom_json", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 9, name: "updated_at", kind: "message", T: () => Timestamp },
            { no: 10, name: "deleted_at", kind: "message", T: () => Timestamp },
            { no: 11, name: "deactivated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = { id: "", role: "", teams: [], language: "", customJson: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string role */ 2:
                    message.role = reader.string();
                    break;
                case /* stream.chat.v2.UserOnlineStatus online_status */ 3:
                    message.onlineStatus = UserOnlineStatus.internalBinaryRead(reader, reader.uint32(), options, message.onlineStatus);
                    break;
                case /* stream.chat.v2.UserBanStatus ban */ 4:
                    message.ban = UserBanStatus.internalBinaryRead(reader, reader.uint32(), options, message.ban);
                    break;
                case /* repeated string teams */ 5:
                    message.teams.push(reader.string());
                    break;
                case /* string language */ 6:
                    message.language = reader.string();
                    break;
                case /* bytes custom_json */ 7:
                    message.customJson = reader.bytes();
                    break;
                case /* google.protobuf.Timestamp created_at */ 8:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 9:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* google.protobuf.Timestamp deleted_at */ 10:
                    message.deletedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                case /* google.protobuf.Timestamp deactivated_at */ 11:
                    message.deactivatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deactivatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string role = 2; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* stream.chat.v2.UserOnlineStatus online_status = 3; */
        if (message.onlineStatus)
            UserOnlineStatus.internalBinaryWrite(message.onlineStatus, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.UserBanStatus ban = 4; */
        if (message.ban)
            UserBanStatus.internalBinaryWrite(message.ban, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string teams = 5; */
        for (let i = 0; i < message.teams.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.teams[i]);
        /* string language = 6; */
        if (message.language !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.language);
        /* bytes custom_json = 7; */
        if (message.customJson.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.customJson);
        /* google.protobuf.Timestamp created_at = 8; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 9; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp deleted_at = 10; */
        if (message.deletedAt)
            Timestamp.internalBinaryWrite(message.deletedAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp deactivated_at = 11; */
        if (message.deactivatedAt)
            Timestamp.internalBinaryWrite(message.deactivatedAt, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserOnlineStatus$Type extends MessageType<UserOnlineStatus> {
    constructor() {
        super("stream.chat.v2.UserOnlineStatus", [
            { no: 1, name: "online", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "last_active_at", kind: "message", T: () => Timestamp },
            { no: 3, name: "invisible", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<UserOnlineStatus>): UserOnlineStatus {
        const message = { online: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserOnlineStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserOnlineStatus): UserOnlineStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool online */ 1:
                    message.online = reader.bool();
                    break;
                case /* google.protobuf.Timestamp last_active_at */ 2:
                    message.lastActiveAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastActiveAt);
                    break;
                case /* google.protobuf.BoolValue invisible */ 3:
                    message.invisible = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.invisible);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserOnlineStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool online = 1; */
        if (message.online !== false)
            writer.tag(1, WireType.Varint).bool(message.online);
        /* google.protobuf.Timestamp last_active_at = 2; */
        if (message.lastActiveAt)
            Timestamp.internalBinaryWrite(message.lastActiveAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue invisible = 3; */
        if (message.invisible)
            BoolValue.internalBinaryWrite(message.invisible, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserOnlineStatus
 */
export const UserOnlineStatus = new UserOnlineStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserBanStatus$Type extends MessageType<UserBanStatus> {
    constructor() {
        super("stream.chat.v2.UserBanStatus", [
            { no: 1, name: "banned", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "ban_expires_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<UserBanStatus>): UserBanStatus {
        const message = { banned: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserBanStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserBanStatus): UserBanStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool banned */ 1:
                    message.banned = reader.bool();
                    break;
                case /* google.protobuf.Timestamp ban_expires_at */ 2:
                    message.banExpiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.banExpiresAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserBanStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool banned = 1; */
        if (message.banned !== false)
            writer.tag(1, WireType.Varint).bool(message.banned);
        /* google.protobuf.Timestamp ban_expires_at = 2; */
        if (message.banExpiresAt)
            Timestamp.internalBinaryWrite(message.banExpiresAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserBanStatus
 */
export const UserBanStatus = new UserBanStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserOwnView$Type extends MessageType<UserOwnView> {
    constructor() {
        super("stream.chat.v2.UserOwnView", [
            { no: 1, name: "user", kind: "message", T: () => User },
            { no: 2, name: "push_settings", kind: "message", T: () => UserPushNotificationsSettings },
            { no: 3, name: "unread", kind: "message", T: () => UserUnreadStatus }
        ]);
    }
    create(value?: PartialMessage<UserOwnView>): UserOwnView {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserOwnView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserOwnView): UserOwnView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.v2.User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* stream.chat.v2.UserPushNotificationsSettings push_settings */ 2:
                    message.pushSettings = UserPushNotificationsSettings.internalBinaryRead(reader, reader.uint32(), options, message.pushSettings);
                    break;
                case /* stream.chat.v2.UserUnreadStatus unread */ 3:
                    message.unread = UserUnreadStatus.internalBinaryRead(reader, reader.uint32(), options, message.unread);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserOwnView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.v2.User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.UserPushNotificationsSettings push_settings = 2; */
        if (message.pushSettings)
            UserPushNotificationsSettings.internalBinaryWrite(message.pushSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.UserUnreadStatus unread = 3; */
        if (message.unread)
            UserUnreadStatus.internalBinaryWrite(message.unread, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserOwnView
 */
export const UserOwnView = new UserOwnView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserSettings$Type extends MessageType<UserSettings> {
    constructor() {
        super("stream.chat.v2.UserSettings", [
            { no: 2, name: "push", kind: "message", T: () => UserPushNotificationsSettings }
        ]);
    }
    create(value?: PartialMessage<UserSettings>): UserSettings {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserSettings): UserSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.v2.UserPushNotificationsSettings push */ 2:
                    message.push = UserPushNotificationsSettings.internalBinaryRead(reader, reader.uint32(), options, message.push);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.v2.UserPushNotificationsSettings push = 2; */
        if (message.push)
            UserPushNotificationsSettings.internalBinaryWrite(message.push, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserSettings
 */
export const UserSettings = new UserSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserPushNotificationsSettings$Type extends MessageType<UserPushNotificationsSettings> {
    constructor() {
        super("stream.chat.v2.UserPushNotificationsSettings", [
            { no: 1, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "disabled_until", kind: "message", T: () => Timestamp },
            { no: 3, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserPushDevice }
        ]);
    }
    create(value?: PartialMessage<UserPushNotificationsSettings>): UserPushNotificationsSettings {
        const message = { disabled: false, devices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserPushNotificationsSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserPushNotificationsSettings): UserPushNotificationsSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool disabled */ 1:
                    message.disabled = reader.bool();
                    break;
                case /* google.protobuf.Timestamp disabled_until */ 2:
                    message.disabledUntil = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.disabledUntil);
                    break;
                case /* repeated stream.chat.v2.UserPushDevice devices */ 3:
                    message.devices.push(UserPushDevice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserPushNotificationsSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool disabled = 1; */
        if (message.disabled !== false)
            writer.tag(1, WireType.Varint).bool(message.disabled);
        /* google.protobuf.Timestamp disabled_until = 2; */
        if (message.disabledUntil)
            Timestamp.internalBinaryWrite(message.disabledUntil, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.chat.v2.UserPushDevice devices = 3; */
        for (let i = 0; i < message.devices.length; i++)
            UserPushDevice.internalBinaryWrite(message.devices[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserPushNotificationsSettings
 */
export const UserPushNotificationsSettings = new UserPushNotificationsSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserPushDevice$Type extends MessageType<UserPushDevice> {
    constructor() {
        super("stream.chat.v2.UserPushDevice", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "push_provider", kind: "enum", T: () => ["stream.chat.v2.PushProvider", PushProvider, "PUSH_PROVIDER_"] },
            { no: 3, name: "push_provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserPushDevice>): UserPushDevice {
        const message = { id: "", pushProvider: 0, pushProviderName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserPushDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserPushDevice): UserPushDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* stream.chat.v2.PushProvider push_provider */ 2:
                    message.pushProvider = reader.int32();
                    break;
                case /* string push_provider_name */ 3:
                    message.pushProviderName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserPushDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* stream.chat.v2.PushProvider push_provider = 2; */
        if (message.pushProvider !== 0)
            writer.tag(2, WireType.Varint).int32(message.pushProvider);
        /* string push_provider_name = 3; */
        if (message.pushProviderName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pushProviderName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserPushDevice
 */
export const UserPushDevice = new UserPushDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserUnreadStatus$Type extends MessageType<UserUnreadStatus> {
    constructor() {
        super("stream.chat.v2.UserUnreadStatus", [
            { no: 1, name: "unread_message_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "unread_channels_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<UserUnreadStatus>): UserUnreadStatus {
        const message = { unreadMessageCount: "0", unreadChannelsCount: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserUnreadStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserUnreadStatus): UserUnreadStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 unread_message_count */ 1:
                    message.unreadMessageCount = reader.int64().toString();
                    break;
                case /* int64 unread_channels_count */ 2:
                    message.unreadChannelsCount = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserUnreadStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 unread_message_count = 1; */
        if (message.unreadMessageCount !== "0")
            writer.tag(1, WireType.Varint).int64(message.unreadMessageCount);
        /* int64 unread_channels_count = 2; */
        if (message.unreadChannelsCount !== "0")
            writer.tag(2, WireType.Varint).int64(message.unreadChannelsCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserUnreadStatus
 */
export const UserUnreadStatus = new UserUnreadStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserLatest$Type extends MessageType<UserLatest> {
    constructor() {
        super("stream.chat.v2.UserLatest", []);
    }
    create(value?: PartialMessage<UserLatest>): UserLatest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserLatest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserLatest): UserLatest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UserLatest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserLatest
 */
export const UserLatest = new UserLatest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserMute$Type extends MessageType<UserMute> {
    constructor() {
        super("stream.chat.v2.UserMute", []);
    }
    create(value?: PartialMessage<UserMute>): UserMute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserMute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserMute): UserMute {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UserMute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserMute
 */
export const UserMute = new UserMute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserChannelMute$Type extends MessageType<UserChannelMute> {
    constructor() {
        super("stream.chat.v2.UserChannelMute", []);
    }
    create(value?: PartialMessage<UserChannelMute>): UserChannelMute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserChannelMute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserChannelMute): UserChannelMute {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UserChannelMute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.UserChannelMute
 */
export const UserChannelMute = new UserChannelMute$Type();
