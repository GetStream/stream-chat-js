// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none
// @generated from protobuf file "chat/v2/channel.proto" (package "stream.chat.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MessageView } from "./message";
import { User } from "./user";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * Channel represents core channel entity
 *
 * @generated from protobuf message stream.chat.v2.Channel
 */
export interface Channel {
    /**
     * The uniquely identifies a channel inside channel type. Channel type and
     * channel ID form channel CID in format <type>:<id>.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The channel type that this channel refers to. Channel type and channel
     * ID form channel CID in format <type>:<id>.
     *
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * created_by_id is an ID of the User who created the channel. Ownership
     * of the channel usually grants additional perimssions to the channel.
     * It's important to note that channel owner is not necessarily a channel
     * member. All channel members have to be added explicitly.
     *
     * @generated from protobuf field: string created_by_id = 3;
     */
    createdById: string;
    /**
     * Whether the channel is disabled.
     *
     * @generated from protobuf field: bool disabled = 4;
     */
    disabled: boolean;
    /**
     * team is a team name that this channel belongs to. Only used for multi-tenant
     * applications. If empty, channel belongs to "empty" team.
     *
     * @generated from protobuf field: string team = 5;
     */
    team: string;
    /**
     * Contains core channel settings
     *
     * @generated from protobuf field: stream.chat.v2.ChannelSettings settings = 6;
     */
    settings?: ChannelSettings;
    /**
     * Contains channel summary statistics that are subject of the frequent change.
     *
     * @generated from protobuf field: stream.chat.v2.ChannelStats stats = 7;
     */
    stats?: ChannelStats;
    /**
     * Contains channel translation settings.
     *
     * @generated from protobuf field: stream.chat.v2.ChannelTranslation translation = 8;
     */
    translation?: ChannelTranslation;
    /**
     * Contains channel truncation information. If empty - channel was never truncated
     *
     * @generated from protobuf field: stream.chat.v2.ChannelTruncationStatus truncated = 9;
     */
    truncated?: ChannelTruncationStatus;
    /**
     * Contains the list of commands that the channel supports.
     *
     * @generated from protobuf field: repeated stream.chat.v2.ChannelCommand commands = 10;
     */
    commands: ChannelCommand[];
    /**
     * custom is a JSON object which contains any channel data. This data can be
     * used for sorting, filtering and data organization.
     *
     * @generated from protobuf field: bytes custom_json = 11;
     */
    customJson: Uint8Array;
    /**
     * The timestamp of channel creation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 12;
     */
    createdAt?: Timestamp;
    /**
     * The timestamp of last channel update.
     *
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 13;
     */
    updatedAt?: Timestamp;
    /**
     * The timestamp of channel deletion. If it's empty - channel is not
     * deleted. Otherwise, channel was soft-deleted.
     *
     * @generated from protobuf field: google.protobuf.Timestamp deleted_at = 14;
     */
    deletedAt?: Timestamp;
}
/**
 * Contains core channel settings.
 *
 * @generated from protobuf message stream.chat.v2.ChannelSettings
 */
export interface ChannelSettings {
    /**
     * Whether the channel is frozen. It's not possible to send new messages
     * and reaction to the frozen channel.
     *
     * @generated from protobuf field: bool frozen = 1;
     */
    frozen: boolean;
    /**
     * A number of seconds that should pass between messages of the single
     * user. It is used to implement "slow mode" feature.
     *
     * @generated from protobuf field: int64 cooldown = 2;
     */
    cooldown: string;
    /**
     * Maximum length of a message (number of unicode characters).
     *
     * @generated from protobuf field: int64 max_message_length = 3;
     */
    maxMessageLength: string;
}
/**
 * Contains channel translation settings.
 *
 * @generated from protobuf message stream.chat.v2.ChannelTranslation
 */
export interface ChannelTranslation {
    /**
     * If Stream should automatically translate messages.
     *
     * @generated from protobuf field: bool auto_translation_enabled = 1;
     */
    autoTranslationEnabled: boolean;
    /**
     * The language code of the translation.
     *
     * @generated from protobuf field: string auto_translation_language = 2;
     */
    autoTranslationLanguage: string;
}
/**
 * Contains channel summary statistics that are subject of the frequent change.
 *
 * @generated from protobuf message stream.chat.v2.ChannelStats
 */
export interface ChannelStats {
    /**
     * Number of members that are in the channel. This field is eventually
     * consistent for channels with high number of members
     *
     * @generated from protobuf field: int64 member_count = 1;
     */
    memberCount: string;
    /**
     * A timestamp of the last message sent to the channel. This field is
     * eventually consistent for channels with very high message rates
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_message_at = 2;
     */
    lastMessageAt?: Timestamp;
}
/**
 * Contains channel truncation information.
 *
 * @generated from protobuf message stream.chat.v2.ChannelTruncationStatus
 */
export interface ChannelTruncationStatus {
    /**
     * A date of channel truncation. Chat history is only available starting
     * from this date.
     *
     * @generated from protobuf field: google.protobuf.Timestamp truncated_at = 1;
     */
    truncatedAt?: Timestamp;
    /**
     * ID of the user who truncated the channel. If it's empty, the channel
     * was truncated using server-side request.
     *
     * @generated from protobuf field: string truncated_by_id = 2;
     */
    truncatedById: string;
}
/**
 * A view that represents channel and core entities surrounding it.
 *
 * @generated from protobuf message stream.chat.v2.ChannelView
 */
export interface ChannelView {
    /**
     * Contains core channel information.
     *
     * @generated from protobuf field: stream.chat.v2.Channel channel = 1;
     */
    channel?: Channel;
    /**
     * Creator of the channel.
     *
     * @generated from protobuf field: stream.chat.v2.User created_by = 2;
     */
    createdBy?: User;
    /**
     * Channel members. Only fist 100 members are provided in this field.
     *
     * @generated from protobuf field: repeated stream.chat.v2.ChannelMemberView members = 3;
     */
    members: ChannelMemberView[];
    /**
     * Latest channel messages sorted ascendingly by the creation date.
     * The number of messages in
     *
     * @generated from protobuf field: repeated stream.chat.v2.MessageView messages = 4;
     */
    messages: MessageView[];
}
/**
 * Represents user's membership inside the channel.
 *
 * @generated from protobuf message stream.chat.v2.ChannelMember
 */
export interface ChannelMember {
    /**
     * User ID the this channel member represents.
     *
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * User's role in the channel.
     *
     * @generated from protobuf field: string channel_role = 2;
     */
    channelRole: string;
    /**
     * Contains invitation information. If it's not provided channel
     * member was not invited, but added directly.
     *
     * @generated from protobuf field: stream.chat.v2.ChannelMemberInvitation invitation = 3;
     */
    invitation?: ChannelMemberInvitation;
    /**
     * Contains ban information. If it's not provided channel member
     * is not banned.
     *
     * @generated from protobuf field: stream.chat.v2.ChannelMemberBan ban = 4;
     */
    ban?: ChannelMemberBan;
    /**
     * Date of channel member creation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5;
     */
    createdAt?: Timestamp;
    /**
     * Date of last channel member update.
     *
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 6;
     */
    updatedAt?: Timestamp;
}
/**
 * A view of ChannelMember that contains extra information.
 *
 * @generated from protobuf message stream.chat.v2.ChannelMemberView
 */
export interface ChannelMemberView {
    /**
     * ChannelMember that this view is for.
     *
     * @generated from protobuf field: stream.chat.v2.ChannelMember channel_member = 1;
     */
    channelMember?: ChannelMember;
    /**
     * A view which contains user information.
     *
     * @generated from protobuf field: stream.chat.v2.User user = 2;
     */
    user?: User;
}
/**
 * Contains channel member invitation data.
 *
 * @generated from protobuf message stream.chat.v2.ChannelMemberInvitation
 */
export interface ChannelMemberInvitation {
    /**
     * Contains the date of invitation acception. If it's empty,
     * the invitation was not accepted.
     *
     * @generated from protobuf field: google.protobuf.Timestamp accepted_at = 1;
     */
    acceptedAt?: Timestamp;
    /**
     * Contains the date of invitation rejection. If it's empty,
     * the invitation was not rejected.
     *
     * @generated from protobuf field: google.protobuf.Timestamp rejected_at = 2;
     */
    rejectedAt?: Timestamp;
}
/**
 * Contains channel member ban information.
 *
 * @generated from protobuf message stream.chat.v2.ChannelMemberBan
 */
export interface ChannelMemberBan {
    /**
     * Expiration date of the ban.
     *
     * @generated from protobuf field: google.protobuf.Timestamp expires_at = 1;
     */
    expiresAt?: Timestamp;
    /**
     * Whether the channel member was shadow banned.
     *
     * @generated from protobuf field: bool shadow = 2;
     */
    shadow: boolean;
}
/**
 * ChannelIdentifier identifies channel with either type and ID pair or type + list of members
 *
 * @generated from protobuf message stream.chat.v2.ChannelIdentifier
 */
export interface ChannelIdentifier {
    /**
     * Channel type
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * Channel ID
     * Either id or member_ids should be used, not both
     *
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * List of channel members (for distinct channels).
     * Either id or member_ids should be used, not both
     *
     * @generated from protobuf field: repeated string member_ids = 3;
     */
    memberIds: string[];
}
/**
 * Contains information about the command.
 *
 * @generated from protobuf message stream.chat.v2.ChannelCommand
 */
export interface ChannelCommand {
    /**
     * Unique command name.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Description, shown in commands auto-completion.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * Arguments help text, shown in commands auto-completion.
     *
     * @generated from protobuf field: string args = 3;
     */
    args: string;
    /**
     * Set name used for grouping commands.
     *
     * @generated from protobuf field: string set = 4;
     */
    set: string;
    /**
     * Date of command creation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5;
     */
    createdAt?: Timestamp;
    /**
     * Date of last command update.
     *
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 6;
     */
    updatedAt?: Timestamp;
}
// @generated message type with reflection information, may provide speed optimized methods
class Channel$Type extends MessageType<Channel> {
    constructor() {
        super("stream.chat.v2.Channel", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "created_by_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "team", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "settings", kind: "message", T: () => ChannelSettings },
            { no: 7, name: "stats", kind: "message", T: () => ChannelStats },
            { no: 8, name: "translation", kind: "message", T: () => ChannelTranslation },
            { no: 9, name: "truncated", kind: "message", T: () => ChannelTruncationStatus },
            { no: 10, name: "commands", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelCommand },
            { no: 11, name: "custom_json", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 13, name: "updated_at", kind: "message", T: () => Timestamp },
            { no: 14, name: "deleted_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Channel>): Channel {
        const message = { id: "", type: "", createdById: "", disabled: false, team: "", commands: [], customJson: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Channel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Channel): Channel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string created_by_id */ 3:
                    message.createdById = reader.string();
                    break;
                case /* bool disabled */ 4:
                    message.disabled = reader.bool();
                    break;
                case /* string team */ 5:
                    message.team = reader.string();
                    break;
                case /* stream.chat.v2.ChannelSettings settings */ 6:
                    message.settings = ChannelSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* stream.chat.v2.ChannelStats stats */ 7:
                    message.stats = ChannelStats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                case /* stream.chat.v2.ChannelTranslation translation */ 8:
                    message.translation = ChannelTranslation.internalBinaryRead(reader, reader.uint32(), options, message.translation);
                    break;
                case /* stream.chat.v2.ChannelTruncationStatus truncated */ 9:
                    message.truncated = ChannelTruncationStatus.internalBinaryRead(reader, reader.uint32(), options, message.truncated);
                    break;
                case /* repeated stream.chat.v2.ChannelCommand commands */ 10:
                    message.commands.push(ChannelCommand.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes custom_json */ 11:
                    message.customJson = reader.bytes();
                    break;
                case /* google.protobuf.Timestamp created_at */ 12:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 13:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* google.protobuf.Timestamp deleted_at */ 14:
                    message.deletedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Channel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string created_by_id = 3; */
        if (message.createdById !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.createdById);
        /* bool disabled = 4; */
        if (message.disabled !== false)
            writer.tag(4, WireType.Varint).bool(message.disabled);
        /* string team = 5; */
        if (message.team !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.team);
        /* stream.chat.v2.ChannelSettings settings = 6; */
        if (message.settings)
            ChannelSettings.internalBinaryWrite(message.settings, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.ChannelStats stats = 7; */
        if (message.stats)
            ChannelStats.internalBinaryWrite(message.stats, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.ChannelTranslation translation = 8; */
        if (message.translation)
            ChannelTranslation.internalBinaryWrite(message.translation, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.ChannelTruncationStatus truncated = 9; */
        if (message.truncated)
            ChannelTruncationStatus.internalBinaryWrite(message.truncated, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.chat.v2.ChannelCommand commands = 10; */
        for (let i = 0; i < message.commands.length; i++)
            ChannelCommand.internalBinaryWrite(message.commands[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bytes custom_json = 11; */
        if (message.customJson.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.customJson);
        /* google.protobuf.Timestamp created_at = 12; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 13; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp deleted_at = 14; */
        if (message.deletedAt)
            Timestamp.internalBinaryWrite(message.deletedAt, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.Channel
 */
export const Channel = new Channel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelSettings$Type extends MessageType<ChannelSettings> {
    constructor() {
        super("stream.chat.v2.ChannelSettings", [
            { no: 1, name: "frozen", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "cooldown", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "max_message_length", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelSettings>): ChannelSettings {
        const message = { frozen: false, cooldown: "0", maxMessageLength: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelSettings): ChannelSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool frozen */ 1:
                    message.frozen = reader.bool();
                    break;
                case /* int64 cooldown */ 2:
                    message.cooldown = reader.int64().toString();
                    break;
                case /* int64 max_message_length */ 3:
                    message.maxMessageLength = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool frozen = 1; */
        if (message.frozen !== false)
            writer.tag(1, WireType.Varint).bool(message.frozen);
        /* int64 cooldown = 2; */
        if (message.cooldown !== "0")
            writer.tag(2, WireType.Varint).int64(message.cooldown);
        /* int64 max_message_length = 3; */
        if (message.maxMessageLength !== "0")
            writer.tag(3, WireType.Varint).int64(message.maxMessageLength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelSettings
 */
export const ChannelSettings = new ChannelSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelTranslation$Type extends MessageType<ChannelTranslation> {
    constructor() {
        super("stream.chat.v2.ChannelTranslation", [
            { no: 1, name: "auto_translation_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "auto_translation_language", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelTranslation>): ChannelTranslation {
        const message = { autoTranslationEnabled: false, autoTranslationLanguage: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelTranslation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelTranslation): ChannelTranslation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool auto_translation_enabled */ 1:
                    message.autoTranslationEnabled = reader.bool();
                    break;
                case /* string auto_translation_language */ 2:
                    message.autoTranslationLanguage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelTranslation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool auto_translation_enabled = 1; */
        if (message.autoTranslationEnabled !== false)
            writer.tag(1, WireType.Varint).bool(message.autoTranslationEnabled);
        /* string auto_translation_language = 2; */
        if (message.autoTranslationLanguage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.autoTranslationLanguage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelTranslation
 */
export const ChannelTranslation = new ChannelTranslation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelStats$Type extends MessageType<ChannelStats> {
    constructor() {
        super("stream.chat.v2.ChannelStats", [
            { no: 1, name: "member_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "last_message_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ChannelStats>): ChannelStats {
        const message = { memberCount: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelStats): ChannelStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 member_count */ 1:
                    message.memberCount = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp last_message_at */ 2:
                    message.lastMessageAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastMessageAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 member_count = 1; */
        if (message.memberCount !== "0")
            writer.tag(1, WireType.Varint).int64(message.memberCount);
        /* google.protobuf.Timestamp last_message_at = 2; */
        if (message.lastMessageAt)
            Timestamp.internalBinaryWrite(message.lastMessageAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelStats
 */
export const ChannelStats = new ChannelStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelTruncationStatus$Type extends MessageType<ChannelTruncationStatus> {
    constructor() {
        super("stream.chat.v2.ChannelTruncationStatus", [
            { no: 1, name: "truncated_at", kind: "message", T: () => Timestamp },
            { no: 2, name: "truncated_by_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelTruncationStatus>): ChannelTruncationStatus {
        const message = { truncatedById: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelTruncationStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelTruncationStatus): ChannelTruncationStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp truncated_at */ 1:
                    message.truncatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.truncatedAt);
                    break;
                case /* string truncated_by_id */ 2:
                    message.truncatedById = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelTruncationStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp truncated_at = 1; */
        if (message.truncatedAt)
            Timestamp.internalBinaryWrite(message.truncatedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string truncated_by_id = 2; */
        if (message.truncatedById !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.truncatedById);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelTruncationStatus
 */
export const ChannelTruncationStatus = new ChannelTruncationStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelView$Type extends MessageType<ChannelView> {
    constructor() {
        super("stream.chat.v2.ChannelView", [
            { no: 1, name: "channel", kind: "message", T: () => Channel },
            { no: 2, name: "created_by", kind: "message", T: () => User },
            { no: 3, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelMemberView },
            { no: 4, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MessageView }
        ]);
    }
    create(value?: PartialMessage<ChannelView>): ChannelView {
        const message = { members: [], messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelView): ChannelView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.v2.Channel channel */ 1:
                    message.channel = Channel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* stream.chat.v2.User created_by */ 2:
                    message.createdBy = User.internalBinaryRead(reader, reader.uint32(), options, message.createdBy);
                    break;
                case /* repeated stream.chat.v2.ChannelMemberView members */ 3:
                    message.members.push(ChannelMemberView.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated stream.chat.v2.MessageView messages */ 4:
                    message.messages.push(MessageView.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.v2.Channel channel = 1; */
        if (message.channel)
            Channel.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.User created_by = 2; */
        if (message.createdBy)
            User.internalBinaryWrite(message.createdBy, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.chat.v2.ChannelMemberView members = 3; */
        for (let i = 0; i < message.members.length; i++)
            ChannelMemberView.internalBinaryWrite(message.members[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.chat.v2.MessageView messages = 4; */
        for (let i = 0; i < message.messages.length; i++)
            MessageView.internalBinaryWrite(message.messages[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelView
 */
export const ChannelView = new ChannelView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelMember$Type extends MessageType<ChannelMember> {
    constructor() {
        super("stream.chat.v2.ChannelMember", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "invitation", kind: "message", T: () => ChannelMemberInvitation },
            { no: 4, name: "ban", kind: "message", T: () => ChannelMemberBan },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 6, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ChannelMember>): ChannelMember {
        const message = { userId: "", channelRole: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelMember>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelMember): ChannelMember {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string channel_role */ 2:
                    message.channelRole = reader.string();
                    break;
                case /* stream.chat.v2.ChannelMemberInvitation invitation */ 3:
                    message.invitation = ChannelMemberInvitation.internalBinaryRead(reader, reader.uint32(), options, message.invitation);
                    break;
                case /* stream.chat.v2.ChannelMemberBan ban */ 4:
                    message.ban = ChannelMemberBan.internalBinaryRead(reader, reader.uint32(), options, message.ban);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 6:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelMember, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string channel_role = 2; */
        if (message.channelRole !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelRole);
        /* stream.chat.v2.ChannelMemberInvitation invitation = 3; */
        if (message.invitation)
            ChannelMemberInvitation.internalBinaryWrite(message.invitation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.ChannelMemberBan ban = 4; */
        if (message.ban)
            ChannelMemberBan.internalBinaryWrite(message.ban, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 6; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelMember
 */
export const ChannelMember = new ChannelMember$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelMemberView$Type extends MessageType<ChannelMemberView> {
    constructor() {
        super("stream.chat.v2.ChannelMemberView", [
            { no: 1, name: "channel_member", kind: "message", T: () => ChannelMember },
            { no: 2, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<ChannelMemberView>): ChannelMemberView {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelMemberView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelMemberView): ChannelMemberView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.v2.ChannelMember channel_member */ 1:
                    message.channelMember = ChannelMember.internalBinaryRead(reader, reader.uint32(), options, message.channelMember);
                    break;
                case /* stream.chat.v2.User user */ 2:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelMemberView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.v2.ChannelMember channel_member = 1; */
        if (message.channelMember)
            ChannelMember.internalBinaryWrite(message.channelMember, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.User user = 2; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelMemberView
 */
export const ChannelMemberView = new ChannelMemberView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelMemberInvitation$Type extends MessageType<ChannelMemberInvitation> {
    constructor() {
        super("stream.chat.v2.ChannelMemberInvitation", [
            { no: 1, name: "accepted_at", kind: "message", T: () => Timestamp },
            { no: 2, name: "rejected_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ChannelMemberInvitation>): ChannelMemberInvitation {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelMemberInvitation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelMemberInvitation): ChannelMemberInvitation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp accepted_at */ 1:
                    message.acceptedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.acceptedAt);
                    break;
                case /* google.protobuf.Timestamp rejected_at */ 2:
                    message.rejectedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.rejectedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelMemberInvitation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp accepted_at = 1; */
        if (message.acceptedAt)
            Timestamp.internalBinaryWrite(message.acceptedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp rejected_at = 2; */
        if (message.rejectedAt)
            Timestamp.internalBinaryWrite(message.rejectedAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelMemberInvitation
 */
export const ChannelMemberInvitation = new ChannelMemberInvitation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelMemberBan$Type extends MessageType<ChannelMemberBan> {
    constructor() {
        super("stream.chat.v2.ChannelMemberBan", [
            { no: 1, name: "expires_at", kind: "message", T: () => Timestamp },
            { no: 2, name: "shadow", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelMemberBan>): ChannelMemberBan {
        const message = { shadow: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelMemberBan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelMemberBan): ChannelMemberBan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp expires_at */ 1:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                case /* bool shadow */ 2:
                    message.shadow = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelMemberBan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp expires_at = 1; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool shadow = 2; */
        if (message.shadow !== false)
            writer.tag(2, WireType.Varint).bool(message.shadow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelMemberBan
 */
export const ChannelMemberBan = new ChannelMemberBan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelIdentifier$Type extends MessageType<ChannelIdentifier> {
    constructor() {
        super("stream.chat.v2.ChannelIdentifier", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "member_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelIdentifier>): ChannelIdentifier {
        const message = { type: "", id: "", memberIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelIdentifier): ChannelIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* repeated string member_ids */ 3:
                    message.memberIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* repeated string member_ids = 3; */
        for (let i = 0; i < message.memberIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.memberIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelIdentifier
 */
export const ChannelIdentifier = new ChannelIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelCommand$Type extends MessageType<ChannelCommand> {
    constructor() {
        super("stream.chat.v2.ChannelCommand", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "args", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "set", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 6, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ChannelCommand>): ChannelCommand {
        const message = { name: "", description: "", args: "", set: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelCommand): ChannelCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string args */ 3:
                    message.args = reader.string();
                    break;
                case /* string set */ 4:
                    message.set = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 6:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string args = 3; */
        if (message.args !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.args);
        /* string set = 4; */
        if (message.set !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.set);
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 6; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.ChannelCommand
 */
export const ChannelCommand = new ChannelCommand$Type();
