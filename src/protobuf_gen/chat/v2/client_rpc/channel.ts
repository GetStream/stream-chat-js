// @generated by protobuf-ts 2.7.0 with parameter long_type_string,generate_dependencies,client_generic,server_none
// @generated from protobuf file "chat/v2/client_rpc/channel.proto" (package "stream.chat.v2.client_rpc", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Sort } from "../utils";
import { Pager } from "../utils";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { ChannelIdentifier } from "../channel";
import { ChannelMemberView } from "../channel";
import { ChannelView } from "../channel";
/**
 * A view which User gets when they request a channel
 *
 * @generated from protobuf message stream.chat.v2.client_rpc.ChannelUserView
 */
export interface ChannelUserView {
    /**
     * Contains base channel view.
     *
     * @generated from protobuf field: stream.chat.v2.ChannelView channel_view = 1;
     */
    channelView?: ChannelView;
    /**
     * Contains user settings for this channel.
     *
     * @generated from protobuf field: stream.chat.v2.client_rpc.ChannelUserSettings user_settings = 2;
     */
    userSettings?: ChannelUserSettings;
    /**
     * List of channel capabilities that are available to the user.
     *
     * @generated from protobuf field: repeated stream.chat.v2.client_rpc.ChannelCapability capabilities = 3;
     */
    capabilities: ChannelCapability[];
    /**
     * Contains information about the authorized user
     * on this channel.
     *
     * @generated from protobuf field: stream.chat.v2.ChannelMemberView membership = 4;
     */
    membership?: ChannelMemberView;
}
/**
 * Request to get or create a channel.
 *
 * @generated from protobuf message stream.chat.v2.client_rpc.GetChannelRequest
 */
export interface GetChannelRequest {
    /**
     * Channel identifier object.
     *
     * @generated from protobuf field: stream.chat.v2.ChannelIdentifier identifier = 1;
     */
    identifier?: ChannelIdentifier;
}
/**
 * Response to get or create a channel.
 *
 * @generated from protobuf message stream.chat.v2.client_rpc.GetChannelResponse
 */
export interface GetChannelResponse {
    /**
     * Contains base channel view.
     *
     * @generated from protobuf field: stream.chat.v2.client_rpc.ChannelUserView channel = 1;
     */
    channel?: ChannelUserView;
}
/**
 * Contains states of the channel for the authorized user.
 *
 * @generated from protobuf message stream.chat.v2.client_rpc.ChannelUserSettings
 */
export interface ChannelUserSettings {
    /**
     * Whether the channel is hidden.
     *
     * @generated from protobuf field: bool hidden = 1;
     */
    hidden: boolean;
    /**
     * Whether the channel is muted.
     *
     * @generated from protobuf field: bool muted = 2;
     */
    muted: boolean;
    /**
     * Contains date of the mute expiration. If it's empty, mute will never expire.
     *
     * @generated from protobuf field: google.protobuf.Timestamp mute_expires_at = 3;
     */
    muteExpiresAt?: Timestamp;
}
/**
 * Request to get the list of channels.
 *
 * @generated from protobuf message stream.chat.v2.client_rpc.QueryChannelRequest
 */
export interface QueryChannelRequest {
    /**
     * Set of filters in MQ format, JSON encoded
     *
     * @generated from protobuf field: bytes mq = 1;
     */
    mq: Uint8Array;
    /**
     * Pager to perform offset based pagination. Default limit is 20 (TODO: validate)
     *
     * @generated from protobuf field: stream.chat.v2.Pager pager = 2;
     */
    pager?: Pager;
    /**
     * Sort is used to provide sort direction. By default channels are sort by XX ASC (TODO: fill this in)
     *
     * @generated from protobuf field: repeated stream.chat.v2.Sort sort = 3;
     */
    sort: Sort[];
}
/**
 * Request to get the list of channels.
 *
 * @generated from protobuf message stream.chat.v2.client_rpc.QueryChannelResponse
 */
export interface QueryChannelResponse {
    /**
     * List of channels.
     *
     * @generated from protobuf field: repeated stream.chat.v2.client_rpc.ChannelUserView channels = 1;
     */
    channels: ChannelUserView[];
}
/**
 * ChannelCapability is a enum containing all known channel capabilities.
 * Each capability takes into account user permissions and features that channel supports
 *
 * @generated from protobuf enum stream.chat.v2.client_rpc.ChannelCapability
 */
export enum ChannelCapability {
    /**
     * Capability is unspecified.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Capability to send messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SEND_MESSAGE = 1;
     */
    SEND_MESSAGE = 1,
    /**
     * Capability to send replies.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SEND_REPLY = 2;
     */
    SEND_REPLY = 2,
    /**
     * Capability to send reactions.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SEND_REACTION = 3;
     */
    SEND_REACTION = 3,
    /**
     * Capability to send links.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SEND_LINKS = 4;
     */
    SEND_LINKS = 4,
    /**
     * Capability to freeze channel.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_FREEZE_CHANNEL = 5;
     */
    FREEZE_CHANNEL = 5,
    /**
     * Capability to modify channel cooldown.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN = 6;
     */
    SET_CHANNEL_COOLDOWN = 6,
    /**
     * Capability to leave the channel.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_LEAVE_CHANNEL = 7;
     */
    LEAVE_CHANNEL = 7,
    /**
     * Capability to join the channel.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_JOIN_CHANNEL = 8;
     */
    JOIN_CHANNEL = 8,
    /**
     * Capability to pin a message.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_PIN_MESSAGE = 9;
     */
    PIN_MESSAGE = 9,
    /**
     * Capability to delete any messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE = 10;
     */
    DELETE_ANY_MESSAGE = 10,
    /**
     * Capability to delete own messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE = 11;
     */
    DELETE_OWN_MESSAGE = 11,
    /**
     * Capability to update any messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE = 12;
     */
    UPDATE_ANY_MESSAGE = 12,
    /**
     * Capability to update own messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE = 13;
     */
    UPDATE_OWN_MESSAGE = 13,
    /**
     * Capability to search messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SEARCH_MESSAGES = 14;
     */
    SEARCH_MESSAGES = 14,
    /**
     * Capability to search messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SEND_TYPING_EVENTS = 15;
     */
    SEND_TYPING_EVENTS = 15,
    /**
     * Capability to upload a file
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_UPLOAD_FILE = 16;
     */
    UPLOAD_FILE = 16,
    /**
     * Capability to delete the channel.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_DELETE_CHANNEL = 17;
     */
    DELETE_CHANNEL = 17,
    /**
     * Capability to update the channel.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_UPDATE_CHANNEL = 18;
     */
    UPDATE_CHANNEL = 18,
    /**
     * Capability to update the channel members.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS = 19;
     */
    UPDATE_CHANNEL_MEMBERS = 19,
    /**
     * Capability to quote messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_QUOTE_MESSAGE = 20;
     */
    QUOTE_MESSAGE = 20,
    /**
     * Capability to ban channel members.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS = 21;
     */
    BAN_CHANNEL_MEMBERS = 21,
    /**
     * Capability to flag messages.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_FLAG_MESSAGE = 22;
     */
    FLAG_MESSAGE = 22,
    /**
     * Capability to mute channel.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_MUTE_CHANNEL = 23;
     */
    MUTE_CHANNEL = 23,
    /**
     * Capability to populate `custom` event.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SEND_CUSTOM_EVENTS = 24;
     */
    SEND_CUSTOM_EVENTS = 24,
    /**
     * Capability to populate `read` event.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_READ_EVENTS = 25;
     */
    READ_EVENTS = 25,
    /**
     * Capability to populate `connect` event.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_CONNECT_EVENTS = 26;
     */
    CONNECT_EVENTS = 26,
    /**
     * Capability to populate `typing` event.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_TYPING_EVENTS = 27;
     */
    TYPING_EVENTS = 27,
    /**
     * Capability to modify slow mode.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_SLOW_MODE = 28;
     */
    SLOW_MODE = 28,
    /**
     * Capability to join a call.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_JOIN_CALL = 29;
     */
    JOIN_CALL = 29,
    /**
     * Capability to create a call.
     *
     * @generated from protobuf enum value: CHANNEL_CAPABILITY_CREATE_CALL = 30;
     */
    CREATE_CALL = 30
}
// @generated message type with reflection information, may provide speed optimized methods
class ChannelUserView$Type extends MessageType<ChannelUserView> {
    constructor() {
        super("stream.chat.v2.client_rpc.ChannelUserView", [
            { no: 1, name: "channel_view", kind: "message", T: () => ChannelView },
            { no: 2, name: "user_settings", kind: "message", T: () => ChannelUserSettings },
            { no: 3, name: "capabilities", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["stream.chat.v2.client_rpc.ChannelCapability", ChannelCapability, "CHANNEL_CAPABILITY_"] },
            { no: 4, name: "membership", kind: "message", T: () => ChannelMemberView }
        ]);
    }
    create(value?: PartialMessage<ChannelUserView>): ChannelUserView {
        const message = { capabilities: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelUserView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelUserView): ChannelUserView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.v2.ChannelView channel_view */ 1:
                    message.channelView = ChannelView.internalBinaryRead(reader, reader.uint32(), options, message.channelView);
                    break;
                case /* stream.chat.v2.client_rpc.ChannelUserSettings user_settings */ 2:
                    message.userSettings = ChannelUserSettings.internalBinaryRead(reader, reader.uint32(), options, message.userSettings);
                    break;
                case /* repeated stream.chat.v2.client_rpc.ChannelCapability capabilities */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.capabilities.push(reader.int32());
                    else
                        message.capabilities.push(reader.int32());
                    break;
                case /* stream.chat.v2.ChannelMemberView membership */ 4:
                    message.membership = ChannelMemberView.internalBinaryRead(reader, reader.uint32(), options, message.membership);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelUserView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.v2.ChannelView channel_view = 1; */
        if (message.channelView)
            ChannelView.internalBinaryWrite(message.channelView, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* stream.chat.v2.client_rpc.ChannelUserSettings user_settings = 2; */
        if (message.userSettings)
            ChannelUserSettings.internalBinaryWrite(message.userSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.chat.v2.client_rpc.ChannelCapability capabilities = 3; */
        if (message.capabilities.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.capabilities.length; i++)
                writer.int32(message.capabilities[i]);
            writer.join();
        }
        /* stream.chat.v2.ChannelMemberView membership = 4; */
        if (message.membership)
            ChannelMemberView.internalBinaryWrite(message.membership, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.client_rpc.ChannelUserView
 */
export const ChannelUserView = new ChannelUserView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChannelRequest$Type extends MessageType<GetChannelRequest> {
    constructor() {
        super("stream.chat.v2.client_rpc.GetChannelRequest", [
            { no: 1, name: "identifier", kind: "message", T: () => ChannelIdentifier }
        ]);
    }
    create(value?: PartialMessage<GetChannelRequest>): GetChannelRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChannelRequest): GetChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.v2.ChannelIdentifier identifier */ 1:
                    message.identifier = ChannelIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.identifier);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.v2.ChannelIdentifier identifier = 1; */
        if (message.identifier)
            ChannelIdentifier.internalBinaryWrite(message.identifier, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.client_rpc.GetChannelRequest
 */
export const GetChannelRequest = new GetChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChannelResponse$Type extends MessageType<GetChannelResponse> {
    constructor() {
        super("stream.chat.v2.client_rpc.GetChannelResponse", [
            { no: 1, name: "channel", kind: "message", T: () => ChannelUserView }
        ]);
    }
    create(value?: PartialMessage<GetChannelResponse>): GetChannelResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetChannelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChannelResponse): GetChannelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* stream.chat.v2.client_rpc.ChannelUserView channel */ 1:
                    message.channel = ChannelUserView.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChannelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* stream.chat.v2.client_rpc.ChannelUserView channel = 1; */
        if (message.channel)
            ChannelUserView.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.client_rpc.GetChannelResponse
 */
export const GetChannelResponse = new GetChannelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelUserSettings$Type extends MessageType<ChannelUserSettings> {
    constructor() {
        super("stream.chat.v2.client_rpc.ChannelUserSettings", [
            { no: 1, name: "hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "muted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "mute_expires_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ChannelUserSettings>): ChannelUserSettings {
        const message = { hidden: false, muted: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelUserSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelUserSettings): ChannelUserSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool hidden */ 1:
                    message.hidden = reader.bool();
                    break;
                case /* bool muted */ 2:
                    message.muted = reader.bool();
                    break;
                case /* google.protobuf.Timestamp mute_expires_at */ 3:
                    message.muteExpiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.muteExpiresAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelUserSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool hidden = 1; */
        if (message.hidden !== false)
            writer.tag(1, WireType.Varint).bool(message.hidden);
        /* bool muted = 2; */
        if (message.muted !== false)
            writer.tag(2, WireType.Varint).bool(message.muted);
        /* google.protobuf.Timestamp mute_expires_at = 3; */
        if (message.muteExpiresAt)
            Timestamp.internalBinaryWrite(message.muteExpiresAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.client_rpc.ChannelUserSettings
 */
export const ChannelUserSettings = new ChannelUserSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelRequest$Type extends MessageType<QueryChannelRequest> {
    constructor() {
        super("stream.chat.v2.client_rpc.QueryChannelRequest", [
            { no: 1, name: "mq", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "pager", kind: "message", T: () => Pager },
            { no: 3, name: "sort", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Sort }
        ]);
    }
    create(value?: PartialMessage<QueryChannelRequest>): QueryChannelRequest {
        const message = { mq: new Uint8Array(0), sort: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelRequest): QueryChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes mq */ 1:
                    message.mq = reader.bytes();
                    break;
                case /* stream.chat.v2.Pager pager */ 2:
                    message.pager = Pager.internalBinaryRead(reader, reader.uint32(), options, message.pager);
                    break;
                case /* repeated stream.chat.v2.Sort sort */ 3:
                    message.sort.push(Sort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes mq = 1; */
        if (message.mq.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.mq);
        /* stream.chat.v2.Pager pager = 2; */
        if (message.pager)
            Pager.internalBinaryWrite(message.pager, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated stream.chat.v2.Sort sort = 3; */
        for (let i = 0; i < message.sort.length; i++)
            Sort.internalBinaryWrite(message.sort[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.client_rpc.QueryChannelRequest
 */
export const QueryChannelRequest = new QueryChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelResponse$Type extends MessageType<QueryChannelResponse> {
    constructor() {
        super("stream.chat.v2.client_rpc.QueryChannelResponse", [
            { no: 1, name: "channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelUserView }
        ]);
    }
    create(value?: PartialMessage<QueryChannelResponse>): QueryChannelResponse {
        const message = { channels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelResponse): QueryChannelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated stream.chat.v2.client_rpc.ChannelUserView channels */ 1:
                    message.channels.push(ChannelUserView.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated stream.chat.v2.client_rpc.ChannelUserView channels = 1; */
        for (let i = 0; i < message.channels.length; i++)
            ChannelUserView.internalBinaryWrite(message.channels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message stream.chat.v2.client_rpc.QueryChannelResponse
 */
export const QueryChannelResponse = new QueryChannelResponse$Type();
