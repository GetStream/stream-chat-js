// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: chat/v2/utils.proto
/* eslint-disable */

import type { ByteSource } from "twirpscript";
import { BinaryReader, BinaryWriter } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export type Direction =
  | "DIRECTION_UNSPECIFIED"
  | "DIRECTION_DESC"
  | "DIRECTION_ASC";

/**
 * Pager is used to perform offset based pagination
 * In most cases it shouldn't be used, use MQ to query next page of data
 */
export interface Pager {
  limit: bigint;
  offset: bigint;
}

export interface Sort {
  field: string;
  direction: Direction;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Direction = {
  DIRECTION_UNSPECIFIED: "DIRECTION_UNSPECIFIED",
  DIRECTION_DESC: "DIRECTION_DESC",
  DIRECTION_ASC: "DIRECTION_ASC",
  /**
   * @private
   */
  _fromInt: function (i: number): Direction {
    switch (i) {
      case 0: {
        return "DIRECTION_UNSPECIFIED";
      }
      case -1: {
        return "DIRECTION_DESC";
      }
      case 1: {
        return "DIRECTION_ASC";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Direction;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Direction): number {
    switch (i) {
      case "DIRECTION_UNSPECIFIED": {
        return 0;
      }
      case "DIRECTION_DESC": {
        return -1;
      }
      case "DIRECTION_ASC": {
        return 1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const Pager = {
  /**
   * Serializes Pager to protobuf.
   */
  encode: function (msg: Partial<Pager>): Uint8Array {
    return Pager._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Pager from protobuf.
   */
  decode: function (bytes: ByteSource): Pager {
    return Pager._readMessage(Pager.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Pager with all fields set to their default value.
   */
  initialize: function (): Pager {
    return {
      limit: 0n,
      offset: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Pager>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.limit) {
      writer.writeInt64String(1, msg.limit.toString() as any);
    }
    if (msg.offset) {
      writer.writeInt64String(2, msg.offset.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pager, reader: BinaryReader): Pager {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.limit = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.offset = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Sort = {
  /**
   * Serializes Sort to protobuf.
   */
  encode: function (msg: Partial<Sort>): Uint8Array {
    return Sort._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Sort from protobuf.
   */
  decode: function (bytes: ByteSource): Sort {
    return Sort._readMessage(Sort.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Sort with all fields set to their default value.
   */
  initialize: function (): Sort {
    return {
      field: "",
      direction: Direction._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Sort>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field) {
      writer.writeString(1, msg.field);
    }
    if (msg.direction && Direction._toInt(msg.direction)) {
      writer.writeEnum(2, Direction._toInt(msg.direction));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Sort, reader: BinaryReader): Sort {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field = reader.readString();
          break;
        }
        case 2: {
          msg.direction = Direction._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const DirectionJSON = {
  DIRECTION_UNSPECIFIED: "DIRECTION_UNSPECIFIED",
  DIRECTION_DESC: "DIRECTION_DESC",
  DIRECTION_ASC: "DIRECTION_ASC",
  /**
   * @private
   */
  _fromInt: function (i: number): Direction {
    switch (i) {
      case 0: {
        return "DIRECTION_UNSPECIFIED";
      }
      case -1: {
        return "DIRECTION_DESC";
      }
      case 1: {
        return "DIRECTION_ASC";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Direction;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Direction): number {
    switch (i) {
      case "DIRECTION_UNSPECIFIED": {
        return 0;
      }
      case "DIRECTION_DESC": {
        return -1;
      }
      case "DIRECTION_ASC": {
        return 1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const PagerJSON = {
  /**
   * Serializes Pager to JSON.
   */
  encode: function (msg: Partial<Pager>): string {
    return JSON.stringify(PagerJSON._writeMessage(msg));
  },

  /**
   * Deserializes Pager from JSON.
   */
  decode: function (json: string): Pager {
    return PagerJSON._readMessage(PagerJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Pager with all fields set to their default value.
   */
  initialize: function (): Pager {
    return {
      limit: 0n,
      offset: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Pager>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.limit) {
      json.limit = msg.limit.toString();
    }
    if (msg.offset) {
      json.offset = msg.offset.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Pager, json: any): Pager {
    const _limit = json.limit;
    if (_limit) {
      msg.limit = BigInt(_limit);
    }
    const _offset = json.offset;
    if (_offset) {
      msg.offset = BigInt(_offset);
    }
    return msg;
  },
};

export const SortJSON = {
  /**
   * Serializes Sort to JSON.
   */
  encode: function (msg: Partial<Sort>): string {
    return JSON.stringify(SortJSON._writeMessage(msg));
  },

  /**
   * Deserializes Sort from JSON.
   */
  decode: function (json: string): Sort {
    return SortJSON._readMessage(SortJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Sort with all fields set to their default value.
   */
  initialize: function (): Sort {
    return {
      field: "",
      direction: Direction._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Sort>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.field) {
      json.field = msg.field;
    }
    if (msg.direction && DirectionJSON._toInt(msg.direction)) {
      json.direction = msg.direction;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Sort, json: any): Sort {
    const _field = json.field;
    if (_field) {
      msg.field = _field;
    }
    const _direction = json.direction;
    if (_direction) {
      msg.direction = _direction;
    }
    return msg;
  },
};
