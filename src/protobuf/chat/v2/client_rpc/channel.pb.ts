// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: chat/v2/client_rpc/channel.proto
/* eslint-disable */

import type { ByteSource } from "twirpscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "twirpscript";

import {
  ChannelView,
  ChannelViewJSON,
  ChannelMemberView,
  ChannelMemberViewJSON,
  ChannelIdentifier,
  ChannelIdentifierJSON,
} from "../channel.pb";
import {
  Timestamp,
  TimestampJSON,
} from "../../../google/protobuf/timestamp.pb";
import { Pager, PagerJSON, Sort, SortJSON } from "../utils.pb";

//========================================//
//                 Types                  //
//========================================//

/**
 * ChannelCapability is a enum containing all known channel capabilities.
 * Each capability takes into account user permissions and features that channel supports
 */
export type ChannelCapability =
  | "CHANNEL_CAPABILITY_UNSPECIFIED"
  | "CHANNEL_CAPABILITY_SEND_MESSAGE"
  | "CHANNEL_CAPABILITY_SEND_REPLY"
  | "CHANNEL_CAPABILITY_SEND_REACTION"
  | "CHANNEL_CAPABILITY_SEND_LINKS"
  | "CHANNEL_CAPABILITY_FREEZE_CHANNEL"
  | "CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN"
  | "CHANNEL_CAPABILITY_LEAVE_CHANNEL"
  | "CHANNEL_CAPABILITY_JOIN_CHANNEL"
  | "CHANNEL_CAPABILITY_PIN_MESSAGE"
  | "CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE"
  | "CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE"
  | "CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE"
  | "CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE"
  | "CHANNEL_CAPABILITY_SEARCH_MESSAGES"
  | "CHANNEL_CAPABILITY_UPLOAD_FILE"
  | "CHANNEL_CAPABILITY_DELETE_CHANNEL"
  | "CHANNEL_CAPABILITY_UPDATE_CHANNEL"
  | "CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS"
  | "CHANNEL_CAPABILITY_QUOTE_MESSAGE"
  | "CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS"
  | "CHANNEL_CAPABILITY_FLAG_MESSAGE"
  | "CHANNEL_CAPABILITY_MUTE_CHANNEL"
  | "CHANNEL_CAPABILITY_SLOW_MODE"
  | "CHANNEL_CAPABILITY_CUSTOM_EVENTS"
  | "CHANNEL_CAPABILITY_READ_EVENTS"
  | "CHANNEL_CAPABILITY_CONNECT_EVENTS"
  | "CHANNEL_CAPABILITY_TYPING_EVENTS";

/**
 * Channel response schema.
 */
export interface ChannelResponse {
  /**
   * Contains base channel view.
   */
  channelView: ChannelView;
  /**
   * Contains user settings for this channel.
   */
  userSettings: ChannelUserSettings;
  /**
   * List of channel capabilities that are available to the user.
   */
  capabilities: ChannelCapability[];
  /**
   * Contains information about the authorized user
   * on this channel.
   */
  membership: ChannelMemberView;
}

/**
 * Request to get or create a channel.
 */
export interface GetChannelRequest {
  /**
   * Channel identifier object.
   */
  identifier: ChannelIdentifier;
}

/**
 * Response to get or create a channel.
 */
export interface GetChannelResponse {
  /**
   * Contains base channel view.
   */
  channel: ChannelResponse;
}

/**
 * Contains states of the channel for the authorized user.
 */
export interface ChannelUserSettings {
  /**
   * Whether the channel is hidden.
   */
  hidden: boolean;
  /**
   * Whether the channel is muted.
   */
  muted: boolean;
  /**
   * Contains date of the mute expiration. If it's empty, mute will never expire.
   */
  muteExpiresAt: Timestamp;
}

/**
 * Request to get the list of channels.
 */
export interface QueryChannelRequest {
  /**
   * Set of filters in MQ format, JSON encoded
   */
  mq: Uint8Array;
  /**
   * Pager to perform offset based pagination. Default limit is 20 (TODO: validate)
   */
  pager: Pager;
  /**
   * Sort is used to provide sort direction. By default channels are sort by XX ASC (TODO: fill this in)
   */
  sort: Sort[];
}

/**
 * Request to get the list of channels.
 */
export interface QueryChannelResponse {
  /**
   * List of channels.
   */
  channels: ChannelResponse[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ChannelCapability = {
  /**
   * Capability is unspecified.
   */
  CHANNEL_CAPABILITY_UNSPECIFIED: "CHANNEL_CAPABILITY_UNSPECIFIED",
  /**
   * Capability to send messages.
   */
  CHANNEL_CAPABILITY_SEND_MESSAGE: "CHANNEL_CAPABILITY_SEND_MESSAGE",
  /**
   * Capability to send replies.
   */
  CHANNEL_CAPABILITY_SEND_REPLY: "CHANNEL_CAPABILITY_SEND_REPLY",
  /**
   * Capability to send reactions.
   */
  CHANNEL_CAPABILITY_SEND_REACTION: "CHANNEL_CAPABILITY_SEND_REACTION",
  /**
   * Capability to send links.
   */
  CHANNEL_CAPABILITY_SEND_LINKS: "CHANNEL_CAPABILITY_SEND_LINKS",
  /**
   * Capability to freeze channel.
   */
  CHANNEL_CAPABILITY_FREEZE_CHANNEL: "CHANNEL_CAPABILITY_FREEZE_CHANNEL",
  /**
   * Capability to modify channel cooldown.
   */
  CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN:
    "CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN",
  /**
   * Capability to leave the channel.
   */
  CHANNEL_CAPABILITY_LEAVE_CHANNEL: "CHANNEL_CAPABILITY_LEAVE_CHANNEL",
  /**
   * Capability to join the channel.
   */
  CHANNEL_CAPABILITY_JOIN_CHANNEL: "CHANNEL_CAPABILITY_JOIN_CHANNEL",
  /**
   * Capability to pin a message.
   */
  CHANNEL_CAPABILITY_PIN_MESSAGE: "CHANNEL_CAPABILITY_PIN_MESSAGE",
  /**
   * Capability to delete any messages.
   */
  CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE:
    "CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE",
  /**
   * Capability to delete own messages.
   */
  CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE:
    "CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE",
  /**
   * Capability to update any messages.
   */
  CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE:
    "CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE",
  /**
   * Capability to update own messages.
   */
  CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE:
    "CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE",
  /**
   * Capability to search messages.
   */
  CHANNEL_CAPABILITY_SEARCH_MESSAGES: "CHANNEL_CAPABILITY_SEARCH_MESSAGES",
  /**
   * Capability to upload a file
   */
  CHANNEL_CAPABILITY_UPLOAD_FILE: "CHANNEL_CAPABILITY_UPLOAD_FILE",
  /**
   * Capability to delete the channel.
   */
  CHANNEL_CAPABILITY_DELETE_CHANNEL: "CHANNEL_CAPABILITY_DELETE_CHANNEL",
  /**
   * Capability to update the channel.
   */
  CHANNEL_CAPABILITY_UPDATE_CHANNEL: "CHANNEL_CAPABILITY_UPDATE_CHANNEL",
  /**
   * Capability to update the channel members.
   */
  CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS:
    "CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS",
  /**
   * Capability to quote messages.
   */
  CHANNEL_CAPABILITY_QUOTE_MESSAGE: "CHANNEL_CAPABILITY_QUOTE_MESSAGE",
  /**
   * Capability to ban channel members.
   */
  CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS:
    "CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS",
  /**
   * Capability to flag messages.
   */
  CHANNEL_CAPABILITY_FLAG_MESSAGE: "CHANNEL_CAPABILITY_FLAG_MESSAGE",
  /**
   * Capability to mute channel.
   */
  CHANNEL_CAPABILITY_MUTE_CHANNEL: "CHANNEL_CAPABILITY_MUTE_CHANNEL",
  /**
   * Capability to modify slow mode.
   */
  CHANNEL_CAPABILITY_SLOW_MODE: "CHANNEL_CAPABILITY_SLOW_MODE",
  /**
   * Capability to populate `custom` event.
   */
  CHANNEL_CAPABILITY_CUSTOM_EVENTS: "CHANNEL_CAPABILITY_CUSTOM_EVENTS",
  /**
   * Capability to populate `read` event.
   */
  CHANNEL_CAPABILITY_READ_EVENTS: "CHANNEL_CAPABILITY_READ_EVENTS",
  /**
   * Capability to populate `connect` event.
   */
  CHANNEL_CAPABILITY_CONNECT_EVENTS: "CHANNEL_CAPABILITY_CONNECT_EVENTS",
  /**
   * Capability to populate `typing` event.
   */
  CHANNEL_CAPABILITY_TYPING_EVENTS: "CHANNEL_CAPABILITY_TYPING_EVENTS",
  /**
   * @private
   */
  _fromInt: function (i: number): ChannelCapability {
    switch (i) {
      case 0: {
        return "CHANNEL_CAPABILITY_UNSPECIFIED";
      }
      case 1: {
        return "CHANNEL_CAPABILITY_SEND_MESSAGE";
      }
      case 2: {
        return "CHANNEL_CAPABILITY_SEND_REPLY";
      }
      case 3: {
        return "CHANNEL_CAPABILITY_SEND_REACTION";
      }
      case 4: {
        return "CHANNEL_CAPABILITY_SEND_LINKS";
      }
      case 5: {
        return "CHANNEL_CAPABILITY_FREEZE_CHANNEL";
      }
      case 6: {
        return "CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN";
      }
      case 7: {
        return "CHANNEL_CAPABILITY_LEAVE_CHANNEL";
      }
      case 8: {
        return "CHANNEL_CAPABILITY_JOIN_CHANNEL";
      }
      case 9: {
        return "CHANNEL_CAPABILITY_PIN_MESSAGE";
      }
      case 10: {
        return "CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE";
      }
      case 11: {
        return "CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE";
      }
      case 12: {
        return "CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE";
      }
      case 13: {
        return "CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE";
      }
      case 14: {
        return "CHANNEL_CAPABILITY_SEARCH_MESSAGES";
      }
      case 15: {
        return "CHANNEL_CAPABILITY_UPLOAD_FILE";
      }
      case 16: {
        return "CHANNEL_CAPABILITY_DELETE_CHANNEL";
      }
      case 17: {
        return "CHANNEL_CAPABILITY_UPDATE_CHANNEL";
      }
      case 18: {
        return "CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS";
      }
      case 19: {
        return "CHANNEL_CAPABILITY_QUOTE_MESSAGE";
      }
      case 20: {
        return "CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS";
      }
      case 21: {
        return "CHANNEL_CAPABILITY_FLAG_MESSAGE";
      }
      case 22: {
        return "CHANNEL_CAPABILITY_MUTE_CHANNEL";
      }
      case 23: {
        return "CHANNEL_CAPABILITY_SLOW_MODE";
      }
      case 24: {
        return "CHANNEL_CAPABILITY_CUSTOM_EVENTS";
      }
      case 25: {
        return "CHANNEL_CAPABILITY_READ_EVENTS";
      }
      case 26: {
        return "CHANNEL_CAPABILITY_CONNECT_EVENTS";
      }
      case 27: {
        return "CHANNEL_CAPABILITY_TYPING_EVENTS";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ChannelCapability;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ChannelCapability): number {
    switch (i) {
      case "CHANNEL_CAPABILITY_UNSPECIFIED": {
        return 0;
      }
      case "CHANNEL_CAPABILITY_SEND_MESSAGE": {
        return 1;
      }
      case "CHANNEL_CAPABILITY_SEND_REPLY": {
        return 2;
      }
      case "CHANNEL_CAPABILITY_SEND_REACTION": {
        return 3;
      }
      case "CHANNEL_CAPABILITY_SEND_LINKS": {
        return 4;
      }
      case "CHANNEL_CAPABILITY_FREEZE_CHANNEL": {
        return 5;
      }
      case "CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN": {
        return 6;
      }
      case "CHANNEL_CAPABILITY_LEAVE_CHANNEL": {
        return 7;
      }
      case "CHANNEL_CAPABILITY_JOIN_CHANNEL": {
        return 8;
      }
      case "CHANNEL_CAPABILITY_PIN_MESSAGE": {
        return 9;
      }
      case "CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE": {
        return 10;
      }
      case "CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE": {
        return 11;
      }
      case "CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE": {
        return 12;
      }
      case "CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE": {
        return 13;
      }
      case "CHANNEL_CAPABILITY_SEARCH_MESSAGES": {
        return 14;
      }
      case "CHANNEL_CAPABILITY_UPLOAD_FILE": {
        return 15;
      }
      case "CHANNEL_CAPABILITY_DELETE_CHANNEL": {
        return 16;
      }
      case "CHANNEL_CAPABILITY_UPDATE_CHANNEL": {
        return 17;
      }
      case "CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS": {
        return 18;
      }
      case "CHANNEL_CAPABILITY_QUOTE_MESSAGE": {
        return 19;
      }
      case "CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS": {
        return 20;
      }
      case "CHANNEL_CAPABILITY_FLAG_MESSAGE": {
        return 21;
      }
      case "CHANNEL_CAPABILITY_MUTE_CHANNEL": {
        return 22;
      }
      case "CHANNEL_CAPABILITY_SLOW_MODE": {
        return 23;
      }
      case "CHANNEL_CAPABILITY_CUSTOM_EVENTS": {
        return 24;
      }
      case "CHANNEL_CAPABILITY_READ_EVENTS": {
        return 25;
      }
      case "CHANNEL_CAPABILITY_CONNECT_EVENTS": {
        return 26;
      }
      case "CHANNEL_CAPABILITY_TYPING_EVENTS": {
        return 27;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ChannelResponse = {
  /**
   * Serializes ChannelResponse to protobuf.
   */
  encode: function (msg: Partial<ChannelResponse>): Uint8Array {
    return ChannelResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelResponse {
    return ChannelResponse._readMessage(
      ChannelResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelResponse with all fields set to their default value.
   */
  initialize: function (): ChannelResponse {
    return {
      channelView: ChannelView.initialize(),
      userSettings: ChannelUserSettings.initialize(),
      capabilities: [],
      membership: ChannelMemberView.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.channelView) {
      writer.writeMessage(1, msg.channelView, ChannelView._writeMessage);
    }
    if (msg.userSettings) {
      writer.writeMessage(
        2,
        msg.userSettings,
        ChannelUserSettings._writeMessage
      );
    }
    if (msg.capabilities?.length) {
      writer.writePackedEnum(3, msg.capabilities.map(ChannelCapability._toInt));
    }
    if (msg.membership) {
      writer.writeMessage(4, msg.membership, ChannelMemberView._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelResponse,
    reader: BinaryReader
  ): ChannelResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.channelView, ChannelView._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(
            msg.userSettings,
            ChannelUserSettings._readMessage
          );
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.capabilities.push(
              ...reader.readPackedEnum().map(ChannelCapability._fromInt)
            );
          } else {
            msg.capabilities.push(
              ChannelCapability._fromInt(reader.readEnum())
            );
          }
          break;
        }
        case 4: {
          reader.readMessage(msg.membership, ChannelMemberView._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetChannelRequest = {
  /**
   * Serializes GetChannelRequest to protobuf.
   */
  encode: function (msg: Partial<GetChannelRequest>): Uint8Array {
    return GetChannelRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetChannelRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetChannelRequest {
    return GetChannelRequest._readMessage(
      GetChannelRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetChannelRequest with all fields set to their default value.
   */
  initialize: function (): GetChannelRequest {
    return {
      identifier: ChannelIdentifier.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetChannelRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.identifier) {
      writer.writeMessage(1, msg.identifier, ChannelIdentifier._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetChannelRequest,
    reader: BinaryReader
  ): GetChannelRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.identifier, ChannelIdentifier._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetChannelResponse = {
  /**
   * Serializes GetChannelResponse to protobuf.
   */
  encode: function (msg: Partial<GetChannelResponse>): Uint8Array {
    return GetChannelResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetChannelResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GetChannelResponse {
    return GetChannelResponse._readMessage(
      GetChannelResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetChannelResponse with all fields set to their default value.
   */
  initialize: function (): GetChannelResponse {
    return {
      channel: ChannelResponse.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetChannelResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.channel) {
      writer.writeMessage(1, msg.channel, ChannelResponse._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetChannelResponse,
    reader: BinaryReader
  ): GetChannelResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.channel, ChannelResponse._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelUserSettings = {
  /**
   * Serializes ChannelUserSettings to protobuf.
   */
  encode: function (msg: Partial<ChannelUserSettings>): Uint8Array {
    return ChannelUserSettings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelUserSettings from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelUserSettings {
    return ChannelUserSettings._readMessage(
      ChannelUserSettings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelUserSettings with all fields set to their default value.
   */
  initialize: function (): ChannelUserSettings {
    return {
      hidden: false,
      muted: false,
      muteExpiresAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelUserSettings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.hidden) {
      writer.writeBool(1, msg.hidden);
    }
    if (msg.muted) {
      writer.writeBool(2, msg.muted);
    }
    if (msg.muteExpiresAt) {
      writer.writeMessage(3, msg.muteExpiresAt, Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelUserSettings,
    reader: BinaryReader
  ): ChannelUserSettings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.hidden = reader.readBool();
          break;
        }
        case 2: {
          msg.muted = reader.readBool();
          break;
        }
        case 3: {
          reader.readMessage(msg.muteExpiresAt, Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const QueryChannelRequest = {
  /**
   * Serializes QueryChannelRequest to protobuf.
   */
  encode: function (msg: Partial<QueryChannelRequest>): Uint8Array {
    return QueryChannelRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes QueryChannelRequest from protobuf.
   */
  decode: function (bytes: ByteSource): QueryChannelRequest {
    return QueryChannelRequest._readMessage(
      QueryChannelRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes QueryChannelRequest with all fields set to their default value.
   */
  initialize: function (): QueryChannelRequest {
    return {
      mq: new Uint8Array(),
      pager: Pager.initialize(),
      sort: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<QueryChannelRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mq?.length) {
      writer.writeBytes(1, msg.mq);
    }
    if (msg.pager) {
      writer.writeMessage(2, msg.pager, Pager._writeMessage);
    }
    if (msg.sort?.length) {
      writer.writeRepeatedMessage(3, msg.sort as any, Sort._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: QueryChannelRequest,
    reader: BinaryReader
  ): QueryChannelRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.mq = reader.readBytes();
          break;
        }
        case 2: {
          reader.readMessage(msg.pager, Pager._readMessage);
          break;
        }
        case 3: {
          const m = Sort.initialize();
          reader.readMessage(m, Sort._readMessage);
          msg.sort.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const QueryChannelResponse = {
  /**
   * Serializes QueryChannelResponse to protobuf.
   */
  encode: function (msg: Partial<QueryChannelResponse>): Uint8Array {
    return QueryChannelResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes QueryChannelResponse from protobuf.
   */
  decode: function (bytes: ByteSource): QueryChannelResponse {
    return QueryChannelResponse._readMessage(
      QueryChannelResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes QueryChannelResponse with all fields set to their default value.
   */
  initialize: function (): QueryChannelResponse {
    return {
      channels: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<QueryChannelResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.channels?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.channels as any,
        ChannelResponse._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: QueryChannelResponse,
    reader: BinaryReader
  ): QueryChannelResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = ChannelResponse.initialize();
          reader.readMessage(m, ChannelResponse._readMessage);
          msg.channels.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ChannelCapabilityJSON = {
  /**
   * Capability is unspecified.
   */
  CHANNEL_CAPABILITY_UNSPECIFIED: "CHANNEL_CAPABILITY_UNSPECIFIED",
  /**
   * Capability to send messages.
   */
  CHANNEL_CAPABILITY_SEND_MESSAGE: "CHANNEL_CAPABILITY_SEND_MESSAGE",
  /**
   * Capability to send replies.
   */
  CHANNEL_CAPABILITY_SEND_REPLY: "CHANNEL_CAPABILITY_SEND_REPLY",
  /**
   * Capability to send reactions.
   */
  CHANNEL_CAPABILITY_SEND_REACTION: "CHANNEL_CAPABILITY_SEND_REACTION",
  /**
   * Capability to send links.
   */
  CHANNEL_CAPABILITY_SEND_LINKS: "CHANNEL_CAPABILITY_SEND_LINKS",
  /**
   * Capability to freeze channel.
   */
  CHANNEL_CAPABILITY_FREEZE_CHANNEL: "CHANNEL_CAPABILITY_FREEZE_CHANNEL",
  /**
   * Capability to modify channel cooldown.
   */
  CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN:
    "CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN",
  /**
   * Capability to leave the channel.
   */
  CHANNEL_CAPABILITY_LEAVE_CHANNEL: "CHANNEL_CAPABILITY_LEAVE_CHANNEL",
  /**
   * Capability to join the channel.
   */
  CHANNEL_CAPABILITY_JOIN_CHANNEL: "CHANNEL_CAPABILITY_JOIN_CHANNEL",
  /**
   * Capability to pin a message.
   */
  CHANNEL_CAPABILITY_PIN_MESSAGE: "CHANNEL_CAPABILITY_PIN_MESSAGE",
  /**
   * Capability to delete any messages.
   */
  CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE:
    "CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE",
  /**
   * Capability to delete own messages.
   */
  CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE:
    "CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE",
  /**
   * Capability to update any messages.
   */
  CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE:
    "CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE",
  /**
   * Capability to update own messages.
   */
  CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE:
    "CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE",
  /**
   * Capability to search messages.
   */
  CHANNEL_CAPABILITY_SEARCH_MESSAGES: "CHANNEL_CAPABILITY_SEARCH_MESSAGES",
  /**
   * Capability to upload a file
   */
  CHANNEL_CAPABILITY_UPLOAD_FILE: "CHANNEL_CAPABILITY_UPLOAD_FILE",
  /**
   * Capability to delete the channel.
   */
  CHANNEL_CAPABILITY_DELETE_CHANNEL: "CHANNEL_CAPABILITY_DELETE_CHANNEL",
  /**
   * Capability to update the channel.
   */
  CHANNEL_CAPABILITY_UPDATE_CHANNEL: "CHANNEL_CAPABILITY_UPDATE_CHANNEL",
  /**
   * Capability to update the channel members.
   */
  CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS:
    "CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS",
  /**
   * Capability to quote messages.
   */
  CHANNEL_CAPABILITY_QUOTE_MESSAGE: "CHANNEL_CAPABILITY_QUOTE_MESSAGE",
  /**
   * Capability to ban channel members.
   */
  CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS:
    "CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS",
  /**
   * Capability to flag messages.
   */
  CHANNEL_CAPABILITY_FLAG_MESSAGE: "CHANNEL_CAPABILITY_FLAG_MESSAGE",
  /**
   * Capability to mute channel.
   */
  CHANNEL_CAPABILITY_MUTE_CHANNEL: "CHANNEL_CAPABILITY_MUTE_CHANNEL",
  /**
   * Capability to modify slow mode.
   */
  CHANNEL_CAPABILITY_SLOW_MODE: "CHANNEL_CAPABILITY_SLOW_MODE",
  /**
   * Capability to populate `custom` event.
   */
  CHANNEL_CAPABILITY_CUSTOM_EVENTS: "CHANNEL_CAPABILITY_CUSTOM_EVENTS",
  /**
   * Capability to populate `read` event.
   */
  CHANNEL_CAPABILITY_READ_EVENTS: "CHANNEL_CAPABILITY_READ_EVENTS",
  /**
   * Capability to populate `connect` event.
   */
  CHANNEL_CAPABILITY_CONNECT_EVENTS: "CHANNEL_CAPABILITY_CONNECT_EVENTS",
  /**
   * Capability to populate `typing` event.
   */
  CHANNEL_CAPABILITY_TYPING_EVENTS: "CHANNEL_CAPABILITY_TYPING_EVENTS",
  /**
   * @private
   */
  _fromInt: function (i: number): ChannelCapability {
    switch (i) {
      case 0: {
        return "CHANNEL_CAPABILITY_UNSPECIFIED";
      }
      case 1: {
        return "CHANNEL_CAPABILITY_SEND_MESSAGE";
      }
      case 2: {
        return "CHANNEL_CAPABILITY_SEND_REPLY";
      }
      case 3: {
        return "CHANNEL_CAPABILITY_SEND_REACTION";
      }
      case 4: {
        return "CHANNEL_CAPABILITY_SEND_LINKS";
      }
      case 5: {
        return "CHANNEL_CAPABILITY_FREEZE_CHANNEL";
      }
      case 6: {
        return "CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN";
      }
      case 7: {
        return "CHANNEL_CAPABILITY_LEAVE_CHANNEL";
      }
      case 8: {
        return "CHANNEL_CAPABILITY_JOIN_CHANNEL";
      }
      case 9: {
        return "CHANNEL_CAPABILITY_PIN_MESSAGE";
      }
      case 10: {
        return "CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE";
      }
      case 11: {
        return "CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE";
      }
      case 12: {
        return "CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE";
      }
      case 13: {
        return "CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE";
      }
      case 14: {
        return "CHANNEL_CAPABILITY_SEARCH_MESSAGES";
      }
      case 15: {
        return "CHANNEL_CAPABILITY_UPLOAD_FILE";
      }
      case 16: {
        return "CHANNEL_CAPABILITY_DELETE_CHANNEL";
      }
      case 17: {
        return "CHANNEL_CAPABILITY_UPDATE_CHANNEL";
      }
      case 18: {
        return "CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS";
      }
      case 19: {
        return "CHANNEL_CAPABILITY_QUOTE_MESSAGE";
      }
      case 20: {
        return "CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS";
      }
      case 21: {
        return "CHANNEL_CAPABILITY_FLAG_MESSAGE";
      }
      case 22: {
        return "CHANNEL_CAPABILITY_MUTE_CHANNEL";
      }
      case 23: {
        return "CHANNEL_CAPABILITY_SLOW_MODE";
      }
      case 24: {
        return "CHANNEL_CAPABILITY_CUSTOM_EVENTS";
      }
      case 25: {
        return "CHANNEL_CAPABILITY_READ_EVENTS";
      }
      case 26: {
        return "CHANNEL_CAPABILITY_CONNECT_EVENTS";
      }
      case 27: {
        return "CHANNEL_CAPABILITY_TYPING_EVENTS";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ChannelCapability;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ChannelCapability): number {
    switch (i) {
      case "CHANNEL_CAPABILITY_UNSPECIFIED": {
        return 0;
      }
      case "CHANNEL_CAPABILITY_SEND_MESSAGE": {
        return 1;
      }
      case "CHANNEL_CAPABILITY_SEND_REPLY": {
        return 2;
      }
      case "CHANNEL_CAPABILITY_SEND_REACTION": {
        return 3;
      }
      case "CHANNEL_CAPABILITY_SEND_LINKS": {
        return 4;
      }
      case "CHANNEL_CAPABILITY_FREEZE_CHANNEL": {
        return 5;
      }
      case "CHANNEL_CAPABILITY_SET_CHANNEL_COOLDOWN": {
        return 6;
      }
      case "CHANNEL_CAPABILITY_LEAVE_CHANNEL": {
        return 7;
      }
      case "CHANNEL_CAPABILITY_JOIN_CHANNEL": {
        return 8;
      }
      case "CHANNEL_CAPABILITY_PIN_MESSAGE": {
        return 9;
      }
      case "CHANNEL_CAPABILITY_DELETE_ANY_MESSAGE": {
        return 10;
      }
      case "CHANNEL_CAPABILITY_DELETE_OWN_MESSAGE": {
        return 11;
      }
      case "CHANNEL_CAPABILITY_UPDATE_ANY_MESSAGE": {
        return 12;
      }
      case "CHANNEL_CAPABILITY_UPDATE_OWN_MESSAGE": {
        return 13;
      }
      case "CHANNEL_CAPABILITY_SEARCH_MESSAGES": {
        return 14;
      }
      case "CHANNEL_CAPABILITY_UPLOAD_FILE": {
        return 15;
      }
      case "CHANNEL_CAPABILITY_DELETE_CHANNEL": {
        return 16;
      }
      case "CHANNEL_CAPABILITY_UPDATE_CHANNEL": {
        return 17;
      }
      case "CHANNEL_CAPABILITY_UPDATE_CHANNEL_MEMBERS": {
        return 18;
      }
      case "CHANNEL_CAPABILITY_QUOTE_MESSAGE": {
        return 19;
      }
      case "CHANNEL_CAPABILITY_BAN_CHANNEL_MEMBERS": {
        return 20;
      }
      case "CHANNEL_CAPABILITY_FLAG_MESSAGE": {
        return 21;
      }
      case "CHANNEL_CAPABILITY_MUTE_CHANNEL": {
        return 22;
      }
      case "CHANNEL_CAPABILITY_SLOW_MODE": {
        return 23;
      }
      case "CHANNEL_CAPABILITY_CUSTOM_EVENTS": {
        return 24;
      }
      case "CHANNEL_CAPABILITY_READ_EVENTS": {
        return 25;
      }
      case "CHANNEL_CAPABILITY_CONNECT_EVENTS": {
        return 26;
      }
      case "CHANNEL_CAPABILITY_TYPING_EVENTS": {
        return 27;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ChannelResponseJSON = {
  /**
   * Serializes ChannelResponse to JSON.
   */
  encode: function (msg: Partial<ChannelResponse>): string {
    return JSON.stringify(ChannelResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelResponse from JSON.
   */
  decode: function (json: string): ChannelResponse {
    return ChannelResponseJSON._readMessage(
      ChannelResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelResponse with all fields set to their default value.
   */
  initialize: function (): ChannelResponse {
    return {
      channelView: ChannelView.initialize(),
      userSettings: ChannelUserSettings.initialize(),
      capabilities: [],
      membership: ChannelMemberView.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.channelView) {
      const channelView = ChannelViewJSON._writeMessage(msg.channelView);
      if (Object.keys(channelView).length > 0) {
        json.channelView = channelView;
      }
    }
    if (msg.userSettings) {
      const userSettings = ChannelUserSettingsJSON._writeMessage(
        msg.userSettings
      );
      if (Object.keys(userSettings).length > 0) {
        json.userSettings = userSettings;
      }
    }
    if (msg.capabilities?.length) {
      json.capabilities = msg.capabilities;
    }
    if (msg.membership) {
      const membership = ChannelMemberViewJSON._writeMessage(msg.membership);
      if (Object.keys(membership).length > 0) {
        json.membership = membership;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChannelResponse, json: any): ChannelResponse {
    const _channelView = json.channelView ?? json.channel_view;
    if (_channelView) {
      const m = ChannelView.initialize();
      ChannelViewJSON._readMessage(m, _channelView);
      msg.channelView = m;
    }
    const _userSettings = json.userSettings ?? json.user_settings;
    if (_userSettings) {
      const m = ChannelUserSettings.initialize();
      ChannelUserSettingsJSON._readMessage(m, _userSettings);
      msg.userSettings = m;
    }
    const _capabilities = json.capabilities;
    if (_capabilities) {
      msg.capabilities = _capabilities;
    }
    const _membership = json.membership;
    if (_membership) {
      const m = ChannelMemberView.initialize();
      ChannelMemberViewJSON._readMessage(m, _membership);
      msg.membership = m;
    }
    return msg;
  },
};

export const GetChannelRequestJSON = {
  /**
   * Serializes GetChannelRequest to JSON.
   */
  encode: function (msg: Partial<GetChannelRequest>): string {
    return JSON.stringify(GetChannelRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetChannelRequest from JSON.
   */
  decode: function (json: string): GetChannelRequest {
    return GetChannelRequestJSON._readMessage(
      GetChannelRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetChannelRequest with all fields set to their default value.
   */
  initialize: function (): GetChannelRequest {
    return {
      identifier: ChannelIdentifier.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetChannelRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.identifier) {
      const identifier = ChannelIdentifierJSON._writeMessage(msg.identifier);
      if (Object.keys(identifier).length > 0) {
        json.identifier = identifier;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetChannelRequest,
    json: any
  ): GetChannelRequest {
    const _identifier = json.identifier;
    if (_identifier) {
      const m = ChannelIdentifier.initialize();
      ChannelIdentifierJSON._readMessage(m, _identifier);
      msg.identifier = m;
    }
    return msg;
  },
};

export const GetChannelResponseJSON = {
  /**
   * Serializes GetChannelResponse to JSON.
   */
  encode: function (msg: Partial<GetChannelResponse>): string {
    return JSON.stringify(GetChannelResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetChannelResponse from JSON.
   */
  decode: function (json: string): GetChannelResponse {
    return GetChannelResponseJSON._readMessage(
      GetChannelResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetChannelResponse with all fields set to their default value.
   */
  initialize: function (): GetChannelResponse {
    return {
      channel: ChannelResponse.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetChannelResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.channel) {
      const channel = ChannelResponseJSON._writeMessage(msg.channel);
      if (Object.keys(channel).length > 0) {
        json.channel = channel;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetChannelResponse,
    json: any
  ): GetChannelResponse {
    const _channel = json.channel;
    if (_channel) {
      const m = ChannelResponse.initialize();
      ChannelResponseJSON._readMessage(m, _channel);
      msg.channel = m;
    }
    return msg;
  },
};

export const ChannelUserSettingsJSON = {
  /**
   * Serializes ChannelUserSettings to JSON.
   */
  encode: function (msg: Partial<ChannelUserSettings>): string {
    return JSON.stringify(ChannelUserSettingsJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelUserSettings from JSON.
   */
  decode: function (json: string): ChannelUserSettings {
    return ChannelUserSettingsJSON._readMessage(
      ChannelUserSettingsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelUserSettings with all fields set to their default value.
   */
  initialize: function (): ChannelUserSettings {
    return {
      hidden: false,
      muted: false,
      muteExpiresAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelUserSettings>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.hidden) {
      json.hidden = msg.hidden;
    }
    if (msg.muted) {
      json.muted = msg.muted;
    }
    if (msg.muteExpiresAt) {
      const muteExpiresAt = TimestampJSON._writeMessage(msg.muteExpiresAt);
      if (Object.keys(muteExpiresAt).length > 0) {
        json.muteExpiresAt = muteExpiresAt;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelUserSettings,
    json: any
  ): ChannelUserSettings {
    const _hidden = json.hidden;
    if (_hidden) {
      msg.hidden = _hidden;
    }
    const _muted = json.muted;
    if (_muted) {
      msg.muted = _muted;
    }
    const _muteExpiresAt = json.muteExpiresAt ?? json.mute_expires_at;
    if (_muteExpiresAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _muteExpiresAt);
      msg.muteExpiresAt = m;
    }
    return msg;
  },
};

export const QueryChannelRequestJSON = {
  /**
   * Serializes QueryChannelRequest to JSON.
   */
  encode: function (msg: Partial<QueryChannelRequest>): string {
    return JSON.stringify(QueryChannelRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes QueryChannelRequest from JSON.
   */
  decode: function (json: string): QueryChannelRequest {
    return QueryChannelRequestJSON._readMessage(
      QueryChannelRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes QueryChannelRequest with all fields set to their default value.
   */
  initialize: function (): QueryChannelRequest {
    return {
      mq: new Uint8Array(),
      pager: Pager.initialize(),
      sort: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<QueryChannelRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mq?.length) {
      json.mq = encodeBase64Bytes(msg.mq);
    }
    if (msg.pager) {
      const pager = PagerJSON._writeMessage(msg.pager);
      if (Object.keys(pager).length > 0) {
        json.pager = pager;
      }
    }
    if (msg.sort?.length) {
      json.sort = msg.sort.map(SortJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: QueryChannelRequest,
    json: any
  ): QueryChannelRequest {
    const _mq = json.mq;
    if (_mq) {
      msg.mq = decodeBase64Bytes(_mq);
    }
    const _pager = json.pager;
    if (_pager) {
      const m = Pager.initialize();
      PagerJSON._readMessage(m, _pager);
      msg.pager = m;
    }
    const _sort = json.sort;
    if (_sort) {
      for (const item of _sort) {
        const m = Sort.initialize();
        SortJSON._readMessage(m, item);
        msg.sort.push(m);
      }
    }
    return msg;
  },
};

export const QueryChannelResponseJSON = {
  /**
   * Serializes QueryChannelResponse to JSON.
   */
  encode: function (msg: Partial<QueryChannelResponse>): string {
    return JSON.stringify(QueryChannelResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes QueryChannelResponse from JSON.
   */
  decode: function (json: string): QueryChannelResponse {
    return QueryChannelResponseJSON._readMessage(
      QueryChannelResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes QueryChannelResponse with all fields set to their default value.
   */
  initialize: function (): QueryChannelResponse {
    return {
      channels: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<QueryChannelResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.channels?.length) {
      json.channels = msg.channels.map(ChannelResponseJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: QueryChannelResponse,
    json: any
  ): QueryChannelResponse {
    const _channels = json.channels;
    if (_channels) {
      for (const item of _channels) {
        const m = ChannelResponse.initialize();
        ChannelResponseJSON._readMessage(m, item);
        msg.channels.push(m);
      }
    }
    return msg;
  },
};
