// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: chat/v2/channel.proto
/* eslint-disable */

import type { ByteSource } from "twirpscript";
import { BinaryReader, BinaryWriter } from "twirpscript";

import { Struct, StructJSON } from "../../google/protobuf/struct.pb";
import { Timestamp, TimestampJSON } from "../../google/protobuf/timestamp.pb";
import { User, UserJSON } from "./user.pb";
import { MessageView, MessageViewJSON } from "./message.pb";

//========================================//
//                 Types                  //
//========================================//

/**
 * Channel represents core channel entity
 */
export interface Channel {
  /**
   * The uniquely identifies a channel inside channel type. Channel type and
   * channel ID form channel CID in format <type>:<id>.
   */
  id: string;
  /**
   * The channel type that this channel refers to. Channel type and channel
   * ID form channel CID in format <type>:<id>.
   */
  type: string;
  /**
   * created_by_id is an ID of the User who created the channel. Ownership
   * of the channel usually grants additional perimssions to the channel.
   * It's important to note that channel owner is not necessarily a channel
   * member. All channel members have to be added explicitly.
   */
  createdById: string;
  /**
   * Whether the channel is disabled.
   */
  disabled: boolean;
  /**
   * team is a team name that this channel belongs to. Only used for multi-tenant
   * applications. If empty, channel belongs to "empty" team.
   */
  team: string;
  /**
   * Contains core channel settings
   */
  settings: ChannelSettings;
  /**
   * Contains channel summary statistics that are subject of the frequent change.
   */
  stats: ChannelStats;
  /**
   * Contains channel translation settings.
   */
  translation: ChannelTranslation;
  /**
   * Contains channel truncation information. If empty - channel was never truncated
   */
  truncated: ChannelTruncationStatus;
  /**
   * Contains the list of commands that the channel supports.
   */
  commands: ChannelCommand[];
  /**
   * custom is a JSON object which contains any channel data. This data can be
   * used for sorting, filtering and data organization.
   */
  custom: Struct;
  /**
   * The timestamp of channel creation.
   */
  createdAt: Timestamp;
  /**
   * The timestamp of last channel update.
   */
  updatedAt: Timestamp;
  /**
   * The timestamp of channel deletion. If it's empty - channel is not
   * deleted. Otherwise, channel was soft-deleted.
   */
  deletedAt: Timestamp;
}

/**
 * Contains core channel settings.
 */
export interface ChannelSettings {
  /**
   * Whether the channel is frozen. It's not possible to send new messages
   * and reaction to the frozen channel.
   */
  frozen: boolean;
  /**
   * A number of seconds that should pass between messages of the single
   * user. It is used to implement "slow mode" feature.
   */
  cooldown: bigint;
  /**
   * Maximum length of a message (number of unicode characters).
   */
  maxMessageLength: bigint;
}

/**
 * Contains channel translation settings.
 */
export interface ChannelTranslation {
  /**
   * If Stream should automatically translate messages.
   */
  autoTranslationEnabled: boolean;
  /**
   * The language code of the translation.
   */
  autoTranslationLanguage: string;
}

/**
 * Contains channel summary statistics that are subject of the frequent change.
 */
export interface ChannelStats {
  /**
   * Number of members that are in the channel. This field is eventually
   * consistent for channels with high number of members
   */
  memberCount: bigint;
  /**
   * A timestamp of the last message sent to the channel. This field is
   * eventually consistent for channels with very high message rates
   */
  lastMessageAt: Timestamp;
}

/**
 * Contains channel truncation information.
 */
export interface ChannelTruncationStatus {
  /**
   * A date of channel truncation. Chat history is only available starting
   * from this date.
   */
  truncatedAt: Timestamp;
  /**
   * ID of the user who truncated the channel. If it's empty, the channel
   * was truncated using server-side request.
   */
  truncatedById: string;
}

/**
 * A view that represents channel and core entities surrounding it.
 */
export interface ChannelView {
  /**
   * Contains core channel information.
   */
  channel: Channel;
  /**
   * Creator of the channel.
   */
  createdBy: User;
  /**
   * Channel members. Only fist 100 members are provided in this field.
   */
  members: ChannelMemberView[];
  /**
   * Latest channel messages sorted ascendingly by the creation date.
   * The number of messages in
   */
  messages: MessageView[];
}

/**
 * Represents user's membership inside the channel.
 */
export interface ChannelMember {
  /**
   * User ID the this channel member represents.
   */
  userId: string;
  /**
   * User's role in the channel.
   */
  channelRole: string;
  /**
   * Contains invitation information. If it's not provided channel
   * member was not invited, but added directly.
   */
  invitation: ChannelMemberInvitation;
  /**
   * Contains ban information. If it's not provided channel member
   * is not banned.
   */
  ban: ChannelMemberBan;
  /**
   * Date of channel member creation.
   */
  createdAt: Timestamp;
  /**
   * Date of last channel member update.
   */
  updatedAt: Timestamp;
}

/**
 * A view of ChannelMember that contains extra information.
 */
export interface ChannelMemberView {
  /**
   * ChannelMember that this view is for.
   */
  channelMember: ChannelMember;
  /**
   * A view which contains user information.
   */
  user: User;
}

/**
 * Contains channel member invitation data.
 */
export interface ChannelMemberInvitation {
  /**
   * Contains the date of invitation acception. If it's empty,
   * the invitation was not accepted.
   */
  acceptedAt: Timestamp;
  /**
   * Contains the date of invitation rejection. If it's empty,
   * the invitation was not rejected.
   */
  rejectedAt: Timestamp;
}

/**
 * Contains channel member ban information.
 */
export interface ChannelMemberBan {
  /**
   * Expiration date of the ban.
   */
  expiresAt: Timestamp;
  /**
   * Whether the channel member was shadow banned.
   */
  shadow: boolean;
}

/**
 * ChannelIdentifier identifies channel with either type and ID pair or type + list of members
 */
export interface ChannelIdentifier {
  /**
   * Channel type
   */
  type: string;
  /**
   * Channel ID
   * Either id or member_ids should be used, not both
   */
  id: string;
  /**
   * List of channel members (for distinct channels).
   * Either id or member_ids should be used, not both
   */
  memberIds: string[];
}

/**
 * Contains information about the command.
 */
export interface ChannelCommand {
  /**
   * Unique command name.
   */
  name: string;
  /**
   * Description, shown in commands auto-completion.
   */
  description: string;
  /**
   * Arguments help text, shown in commands auto-completion.
   */
  args: string;
  /**
   * Set name used for grouping commands.
   */
  set: string;
  /**
   * Date of command creation.
   */
  createdAt: Timestamp;
  /**
   * Date of last command update.
   */
  updatedAt: Timestamp;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Channel = {
  /**
   * Serializes Channel to protobuf.
   */
  encode: function (msg: Partial<Channel>): Uint8Array {
    return Channel._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Channel from protobuf.
   */
  decode: function (bytes: ByteSource): Channel {
    return Channel._readMessage(Channel.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Channel with all fields set to their default value.
   */
  initialize: function (): Channel {
    return {
      id: "",
      type: "",
      createdById: "",
      disabled: false,
      team: "",
      settings: ChannelSettings.initialize(),
      stats: ChannelStats.initialize(),
      translation: ChannelTranslation.initialize(),
      truncated: ChannelTruncationStatus.initialize(),
      commands: [],
      custom: Struct.initialize(),
      createdAt: Timestamp.initialize(),
      updatedAt: Timestamp.initialize(),
      deletedAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Channel>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.type) {
      writer.writeString(2, msg.type);
    }
    if (msg.createdById) {
      writer.writeString(3, msg.createdById);
    }
    if (msg.disabled) {
      writer.writeBool(4, msg.disabled);
    }
    if (msg.team) {
      writer.writeString(5, msg.team);
    }
    if (msg.settings) {
      writer.writeMessage(6, msg.settings, ChannelSettings._writeMessage);
    }
    if (msg.stats) {
      writer.writeMessage(7, msg.stats, ChannelStats._writeMessage);
    }
    if (msg.translation) {
      writer.writeMessage(8, msg.translation, ChannelTranslation._writeMessage);
    }
    if (msg.truncated) {
      writer.writeMessage(
        9,
        msg.truncated,
        ChannelTruncationStatus._writeMessage
      );
    }
    if (msg.commands?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.commands as any,
        ChannelCommand._writeMessage
      );
    }
    if (msg.custom) {
      writer.writeMessage(11, msg.custom, Struct._writeMessage);
    }
    if (msg.createdAt) {
      writer.writeMessage(12, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.updatedAt) {
      writer.writeMessage(13, msg.updatedAt, Timestamp._writeMessage);
    }
    if (msg.deletedAt) {
      writer.writeMessage(14, msg.deletedAt, Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Channel, reader: BinaryReader): Channel {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.type = reader.readString();
          break;
        }
        case 3: {
          msg.createdById = reader.readString();
          break;
        }
        case 4: {
          msg.disabled = reader.readBool();
          break;
        }
        case 5: {
          msg.team = reader.readString();
          break;
        }
        case 6: {
          reader.readMessage(msg.settings, ChannelSettings._readMessage);
          break;
        }
        case 7: {
          reader.readMessage(msg.stats, ChannelStats._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.translation, ChannelTranslation._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(
            msg.truncated,
            ChannelTruncationStatus._readMessage
          );
          break;
        }
        case 10: {
          const m = ChannelCommand.initialize();
          reader.readMessage(m, ChannelCommand._readMessage);
          msg.commands.push(m);
          break;
        }
        case 11: {
          reader.readMessage(msg.custom, Struct._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.updatedAt, Timestamp._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.deletedAt, Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelSettings = {
  /**
   * Serializes ChannelSettings to protobuf.
   */
  encode: function (msg: Partial<ChannelSettings>): Uint8Array {
    return ChannelSettings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelSettings from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelSettings {
    return ChannelSettings._readMessage(
      ChannelSettings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelSettings with all fields set to their default value.
   */
  initialize: function (): ChannelSettings {
    return {
      frozen: false,
      cooldown: 0n,
      maxMessageLength: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelSettings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.frozen) {
      writer.writeBool(1, msg.frozen);
    }
    if (msg.cooldown) {
      writer.writeInt64String(2, msg.cooldown.toString() as any);
    }
    if (msg.maxMessageLength) {
      writer.writeInt64String(3, msg.maxMessageLength.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelSettings,
    reader: BinaryReader
  ): ChannelSettings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.frozen = reader.readBool();
          break;
        }
        case 2: {
          msg.cooldown = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.maxMessageLength = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelTranslation = {
  /**
   * Serializes ChannelTranslation to protobuf.
   */
  encode: function (msg: Partial<ChannelTranslation>): Uint8Array {
    return ChannelTranslation._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelTranslation from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelTranslation {
    return ChannelTranslation._readMessage(
      ChannelTranslation.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelTranslation with all fields set to their default value.
   */
  initialize: function (): ChannelTranslation {
    return {
      autoTranslationEnabled: false,
      autoTranslationLanguage: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelTranslation>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.autoTranslationEnabled) {
      writer.writeBool(1, msg.autoTranslationEnabled);
    }
    if (msg.autoTranslationLanguage) {
      writer.writeString(2, msg.autoTranslationLanguage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelTranslation,
    reader: BinaryReader
  ): ChannelTranslation {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.autoTranslationEnabled = reader.readBool();
          break;
        }
        case 2: {
          msg.autoTranslationLanguage = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelStats = {
  /**
   * Serializes ChannelStats to protobuf.
   */
  encode: function (msg: Partial<ChannelStats>): Uint8Array {
    return ChannelStats._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelStats from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelStats {
    return ChannelStats._readMessage(
      ChannelStats.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelStats with all fields set to their default value.
   */
  initialize: function (): ChannelStats {
    return {
      memberCount: 0n,
      lastMessageAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelStats>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.memberCount) {
      writer.writeInt64String(1, msg.memberCount.toString() as any);
    }
    if (msg.lastMessageAt) {
      writer.writeMessage(2, msg.lastMessageAt, Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelStats,
    reader: BinaryReader
  ): ChannelStats {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.memberCount = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          reader.readMessage(msg.lastMessageAt, Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelTruncationStatus = {
  /**
   * Serializes ChannelTruncationStatus to protobuf.
   */
  encode: function (msg: Partial<ChannelTruncationStatus>): Uint8Array {
    return ChannelTruncationStatus._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelTruncationStatus from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelTruncationStatus {
    return ChannelTruncationStatus._readMessage(
      ChannelTruncationStatus.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelTruncationStatus with all fields set to their default value.
   */
  initialize: function (): ChannelTruncationStatus {
    return {
      truncatedAt: Timestamp.initialize(),
      truncatedById: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelTruncationStatus>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.truncatedAt) {
      writer.writeMessage(1, msg.truncatedAt, Timestamp._writeMessage);
    }
    if (msg.truncatedById) {
      writer.writeString(2, msg.truncatedById);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelTruncationStatus,
    reader: BinaryReader
  ): ChannelTruncationStatus {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.truncatedAt, Timestamp._readMessage);
          break;
        }
        case 2: {
          msg.truncatedById = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelView = {
  /**
   * Serializes ChannelView to protobuf.
   */
  encode: function (msg: Partial<ChannelView>): Uint8Array {
    return ChannelView._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes ChannelView from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelView {
    return ChannelView._readMessage(
      ChannelView.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelView with all fields set to their default value.
   */
  initialize: function (): ChannelView {
    return {
      channel: Channel.initialize(),
      createdBy: User.initialize(),
      members: [],
      messages: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelView>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.channel) {
      writer.writeMessage(1, msg.channel, Channel._writeMessage);
    }
    if (msg.createdBy) {
      writer.writeMessage(2, msg.createdBy, User._writeMessage);
    }
    if (msg.members?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.members as any,
        ChannelMemberView._writeMessage
      );
    }
    if (msg.messages?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.messages as any,
        MessageView._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChannelView, reader: BinaryReader): ChannelView {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.channel, Channel._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.createdBy, User._readMessage);
          break;
        }
        case 3: {
          const m = ChannelMemberView.initialize();
          reader.readMessage(m, ChannelMemberView._readMessage);
          msg.members.push(m);
          break;
        }
        case 4: {
          const m = MessageView.initialize();
          reader.readMessage(m, MessageView._readMessage);
          msg.messages.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelMember = {
  /**
   * Serializes ChannelMember to protobuf.
   */
  encode: function (msg: Partial<ChannelMember>): Uint8Array {
    return ChannelMember._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelMember from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelMember {
    return ChannelMember._readMessage(
      ChannelMember.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelMember with all fields set to their default value.
   */
  initialize: function (): ChannelMember {
    return {
      userId: "",
      channelRole: "",
      invitation: ChannelMemberInvitation.initialize(),
      ban: ChannelMemberBan.initialize(),
      createdAt: Timestamp.initialize(),
      updatedAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelMember>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.userId) {
      writer.writeString(1, msg.userId);
    }
    if (msg.channelRole) {
      writer.writeString(2, msg.channelRole);
    }
    if (msg.invitation) {
      writer.writeMessage(
        3,
        msg.invitation,
        ChannelMemberInvitation._writeMessage
      );
    }
    if (msg.ban) {
      writer.writeMessage(4, msg.ban, ChannelMemberBan._writeMessage);
    }
    if (msg.createdAt) {
      writer.writeMessage(5, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.updatedAt) {
      writer.writeMessage(6, msg.updatedAt, Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelMember,
    reader: BinaryReader
  ): ChannelMember {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.userId = reader.readString();
          break;
        }
        case 2: {
          msg.channelRole = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.invitation,
            ChannelMemberInvitation._readMessage
          );
          break;
        }
        case 4: {
          reader.readMessage(msg.ban, ChannelMemberBan._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(msg.updatedAt, Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelMemberView = {
  /**
   * Serializes ChannelMemberView to protobuf.
   */
  encode: function (msg: Partial<ChannelMemberView>): Uint8Array {
    return ChannelMemberView._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelMemberView from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelMemberView {
    return ChannelMemberView._readMessage(
      ChannelMemberView.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelMemberView with all fields set to their default value.
   */
  initialize: function (): ChannelMemberView {
    return {
      channelMember: ChannelMember.initialize(),
      user: User.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelMemberView>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.channelMember) {
      writer.writeMessage(1, msg.channelMember, ChannelMember._writeMessage);
    }
    if (msg.user) {
      writer.writeMessage(2, msg.user, User._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelMemberView,
    reader: BinaryReader
  ): ChannelMemberView {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.channelMember, ChannelMember._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.user, User._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelMemberInvitation = {
  /**
   * Serializes ChannelMemberInvitation to protobuf.
   */
  encode: function (msg: Partial<ChannelMemberInvitation>): Uint8Array {
    return ChannelMemberInvitation._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelMemberInvitation from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelMemberInvitation {
    return ChannelMemberInvitation._readMessage(
      ChannelMemberInvitation.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelMemberInvitation with all fields set to their default value.
   */
  initialize: function (): ChannelMemberInvitation {
    return {
      acceptedAt: Timestamp.initialize(),
      rejectedAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelMemberInvitation>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.acceptedAt) {
      writer.writeMessage(1, msg.acceptedAt, Timestamp._writeMessage);
    }
    if (msg.rejectedAt) {
      writer.writeMessage(2, msg.rejectedAt, Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelMemberInvitation,
    reader: BinaryReader
  ): ChannelMemberInvitation {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.acceptedAt, Timestamp._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.rejectedAt, Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelMemberBan = {
  /**
   * Serializes ChannelMemberBan to protobuf.
   */
  encode: function (msg: Partial<ChannelMemberBan>): Uint8Array {
    return ChannelMemberBan._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelMemberBan from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelMemberBan {
    return ChannelMemberBan._readMessage(
      ChannelMemberBan.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelMemberBan with all fields set to their default value.
   */
  initialize: function (): ChannelMemberBan {
    return {
      expiresAt: Timestamp.initialize(),
      shadow: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelMemberBan>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.expiresAt) {
      writer.writeMessage(1, msg.expiresAt, Timestamp._writeMessage);
    }
    if (msg.shadow) {
      writer.writeBool(2, msg.shadow);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelMemberBan,
    reader: BinaryReader
  ): ChannelMemberBan {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.expiresAt, Timestamp._readMessage);
          break;
        }
        case 2: {
          msg.shadow = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelIdentifier = {
  /**
   * Serializes ChannelIdentifier to protobuf.
   */
  encode: function (msg: Partial<ChannelIdentifier>): Uint8Array {
    return ChannelIdentifier._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelIdentifier from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelIdentifier {
    return ChannelIdentifier._readMessage(
      ChannelIdentifier.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelIdentifier with all fields set to their default value.
   */
  initialize: function (): ChannelIdentifier {
    return {
      type: "",
      id: "",
      memberIds: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelIdentifier>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.type) {
      writer.writeString(1, msg.type);
    }
    if (msg.id) {
      writer.writeString(2, msg.id);
    }
    if (msg.memberIds?.length) {
      writer.writeRepeatedString(3, msg.memberIds);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelIdentifier,
    reader: BinaryReader
  ): ChannelIdentifier {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.type = reader.readString();
          break;
        }
        case 2: {
          msg.id = reader.readString();
          break;
        }
        case 3: {
          msg.memberIds.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ChannelCommand = {
  /**
   * Serializes ChannelCommand to protobuf.
   */
  encode: function (msg: Partial<ChannelCommand>): Uint8Array {
    return ChannelCommand._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes ChannelCommand from protobuf.
   */
  decode: function (bytes: ByteSource): ChannelCommand {
    return ChannelCommand._readMessage(
      ChannelCommand.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ChannelCommand with all fields set to their default value.
   */
  initialize: function (): ChannelCommand {
    return {
      name: "",
      description: "",
      args: "",
      set: "",
      createdAt: Timestamp.initialize(),
      updatedAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelCommand>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.description) {
      writer.writeString(2, msg.description);
    }
    if (msg.args) {
      writer.writeString(3, msg.args);
    }
    if (msg.set) {
      writer.writeString(4, msg.set);
    }
    if (msg.createdAt) {
      writer.writeMessage(5, msg.createdAt, Timestamp._writeMessage);
    }
    if (msg.updatedAt) {
      writer.writeMessage(6, msg.updatedAt, Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelCommand,
    reader: BinaryReader
  ): ChannelCommand {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.description = reader.readString();
          break;
        }
        case 3: {
          msg.args = reader.readString();
          break;
        }
        case 4: {
          msg.set = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.createdAt, Timestamp._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(msg.updatedAt, Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ChannelJSON = {
  /**
   * Serializes Channel to JSON.
   */
  encode: function (msg: Partial<Channel>): string {
    return JSON.stringify(ChannelJSON._writeMessage(msg));
  },

  /**
   * Deserializes Channel from JSON.
   */
  decode: function (json: string): Channel {
    return ChannelJSON._readMessage(ChannelJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Channel with all fields set to their default value.
   */
  initialize: function (): Channel {
    return {
      id: "",
      type: "",
      createdById: "",
      disabled: false,
      team: "",
      settings: ChannelSettings.initialize(),
      stats: ChannelStats.initialize(),
      translation: ChannelTranslation.initialize(),
      truncated: ChannelTruncationStatus.initialize(),
      commands: [],
      custom: Struct.initialize(),
      createdAt: Timestamp.initialize(),
      updatedAt: Timestamp.initialize(),
      deletedAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Channel>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.type) {
      json.type = msg.type;
    }
    if (msg.createdById) {
      json.createdById = msg.createdById;
    }
    if (msg.disabled) {
      json.disabled = msg.disabled;
    }
    if (msg.team) {
      json.team = msg.team;
    }
    if (msg.settings) {
      const settings = ChannelSettingsJSON._writeMessage(msg.settings);
      if (Object.keys(settings).length > 0) {
        json.settings = settings;
      }
    }
    if (msg.stats) {
      const stats = ChannelStatsJSON._writeMessage(msg.stats);
      if (Object.keys(stats).length > 0) {
        json.stats = stats;
      }
    }
    if (msg.translation) {
      const translation = ChannelTranslationJSON._writeMessage(msg.translation);
      if (Object.keys(translation).length > 0) {
        json.translation = translation;
      }
    }
    if (msg.truncated) {
      const truncated = ChannelTruncationStatusJSON._writeMessage(
        msg.truncated
      );
      if (Object.keys(truncated).length > 0) {
        json.truncated = truncated;
      }
    }
    if (msg.commands?.length) {
      json.commands = msg.commands.map(ChannelCommandJSON._writeMessage);
    }
    if (msg.custom) {
      const custom = StructJSON._writeMessage(msg.custom);
      if (Object.keys(custom).length > 0) {
        json.custom = custom;
      }
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.updatedAt) {
      const updatedAt = TimestampJSON._writeMessage(msg.updatedAt);
      if (Object.keys(updatedAt).length > 0) {
        json.updatedAt = updatedAt;
      }
    }
    if (msg.deletedAt) {
      const deletedAt = TimestampJSON._writeMessage(msg.deletedAt);
      if (Object.keys(deletedAt).length > 0) {
        json.deletedAt = deletedAt;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Channel, json: any): Channel {
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _type = json.type;
    if (_type) {
      msg.type = _type;
    }
    const _createdById = json.createdById ?? json.created_by_id;
    if (_createdById) {
      msg.createdById = _createdById;
    }
    const _disabled = json.disabled;
    if (_disabled) {
      msg.disabled = _disabled;
    }
    const _team = json.team;
    if (_team) {
      msg.team = _team;
    }
    const _settings = json.settings;
    if (_settings) {
      const m = ChannelSettings.initialize();
      ChannelSettingsJSON._readMessage(m, _settings);
      msg.settings = m;
    }
    const _stats = json.stats;
    if (_stats) {
      const m = ChannelStats.initialize();
      ChannelStatsJSON._readMessage(m, _stats);
      msg.stats = m;
    }
    const _translation = json.translation;
    if (_translation) {
      const m = ChannelTranslation.initialize();
      ChannelTranslationJSON._readMessage(m, _translation);
      msg.translation = m;
    }
    const _truncated = json.truncated;
    if (_truncated) {
      const m = ChannelTruncationStatus.initialize();
      ChannelTruncationStatusJSON._readMessage(m, _truncated);
      msg.truncated = m;
    }
    const _commands = json.commands;
    if (_commands) {
      for (const item of _commands) {
        const m = ChannelCommand.initialize();
        ChannelCommandJSON._readMessage(m, item);
        msg.commands.push(m);
      }
    }
    const _custom = json.custom;
    if (_custom) {
      const m = Struct.initialize();
      StructJSON._readMessage(m, _custom);
      msg.custom = m;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _updatedAt = json.updatedAt ?? json.updated_at;
    if (_updatedAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _updatedAt);
      msg.updatedAt = m;
    }
    const _deletedAt = json.deletedAt ?? json.deleted_at;
    if (_deletedAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _deletedAt);
      msg.deletedAt = m;
    }
    return msg;
  },
};

export const ChannelSettingsJSON = {
  /**
   * Serializes ChannelSettings to JSON.
   */
  encode: function (msg: Partial<ChannelSettings>): string {
    return JSON.stringify(ChannelSettingsJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelSettings from JSON.
   */
  decode: function (json: string): ChannelSettings {
    return ChannelSettingsJSON._readMessage(
      ChannelSettingsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelSettings with all fields set to their default value.
   */
  initialize: function (): ChannelSettings {
    return {
      frozen: false,
      cooldown: 0n,
      maxMessageLength: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelSettings>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.frozen) {
      json.frozen = msg.frozen;
    }
    if (msg.cooldown) {
      json.cooldown = msg.cooldown.toString();
    }
    if (msg.maxMessageLength) {
      json.maxMessageLength = msg.maxMessageLength.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChannelSettings, json: any): ChannelSettings {
    const _frozen = json.frozen;
    if (_frozen) {
      msg.frozen = _frozen;
    }
    const _cooldown = json.cooldown;
    if (_cooldown) {
      msg.cooldown = BigInt(_cooldown);
    }
    const _maxMessageLength = json.maxMessageLength ?? json.max_message_length;
    if (_maxMessageLength) {
      msg.maxMessageLength = BigInt(_maxMessageLength);
    }
    return msg;
  },
};

export const ChannelTranslationJSON = {
  /**
   * Serializes ChannelTranslation to JSON.
   */
  encode: function (msg: Partial<ChannelTranslation>): string {
    return JSON.stringify(ChannelTranslationJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelTranslation from JSON.
   */
  decode: function (json: string): ChannelTranslation {
    return ChannelTranslationJSON._readMessage(
      ChannelTranslationJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelTranslation with all fields set to their default value.
   */
  initialize: function (): ChannelTranslation {
    return {
      autoTranslationEnabled: false,
      autoTranslationLanguage: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelTranslation>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.autoTranslationEnabled) {
      json.autoTranslationEnabled = msg.autoTranslationEnabled;
    }
    if (msg.autoTranslationLanguage) {
      json.autoTranslationLanguage = msg.autoTranslationLanguage;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelTranslation,
    json: any
  ): ChannelTranslation {
    const _autoTranslationEnabled =
      json.autoTranslationEnabled ?? json.auto_translation_enabled;
    if (_autoTranslationEnabled) {
      msg.autoTranslationEnabled = _autoTranslationEnabled;
    }
    const _autoTranslationLanguage =
      json.autoTranslationLanguage ?? json.auto_translation_language;
    if (_autoTranslationLanguage) {
      msg.autoTranslationLanguage = _autoTranslationLanguage;
    }
    return msg;
  },
};

export const ChannelStatsJSON = {
  /**
   * Serializes ChannelStats to JSON.
   */
  encode: function (msg: Partial<ChannelStats>): string {
    return JSON.stringify(ChannelStatsJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelStats from JSON.
   */
  decode: function (json: string): ChannelStats {
    return ChannelStatsJSON._readMessage(
      ChannelStatsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelStats with all fields set to their default value.
   */
  initialize: function (): ChannelStats {
    return {
      memberCount: 0n,
      lastMessageAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelStats>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.memberCount) {
      json.memberCount = msg.memberCount.toString();
    }
    if (msg.lastMessageAt) {
      const lastMessageAt = TimestampJSON._writeMessage(msg.lastMessageAt);
      if (Object.keys(lastMessageAt).length > 0) {
        json.lastMessageAt = lastMessageAt;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChannelStats, json: any): ChannelStats {
    const _memberCount = json.memberCount ?? json.member_count;
    if (_memberCount) {
      msg.memberCount = BigInt(_memberCount);
    }
    const _lastMessageAt = json.lastMessageAt ?? json.last_message_at;
    if (_lastMessageAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _lastMessageAt);
      msg.lastMessageAt = m;
    }
    return msg;
  },
};

export const ChannelTruncationStatusJSON = {
  /**
   * Serializes ChannelTruncationStatus to JSON.
   */
  encode: function (msg: Partial<ChannelTruncationStatus>): string {
    return JSON.stringify(ChannelTruncationStatusJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelTruncationStatus from JSON.
   */
  decode: function (json: string): ChannelTruncationStatus {
    return ChannelTruncationStatusJSON._readMessage(
      ChannelTruncationStatusJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelTruncationStatus with all fields set to their default value.
   */
  initialize: function (): ChannelTruncationStatus {
    return {
      truncatedAt: Timestamp.initialize(),
      truncatedById: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelTruncationStatus>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.truncatedAt) {
      const truncatedAt = TimestampJSON._writeMessage(msg.truncatedAt);
      if (Object.keys(truncatedAt).length > 0) {
        json.truncatedAt = truncatedAt;
      }
    }
    if (msg.truncatedById) {
      json.truncatedById = msg.truncatedById;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelTruncationStatus,
    json: any
  ): ChannelTruncationStatus {
    const _truncatedAt = json.truncatedAt ?? json.truncated_at;
    if (_truncatedAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _truncatedAt);
      msg.truncatedAt = m;
    }
    const _truncatedById = json.truncatedById ?? json.truncated_by_id;
    if (_truncatedById) {
      msg.truncatedById = _truncatedById;
    }
    return msg;
  },
};

export const ChannelViewJSON = {
  /**
   * Serializes ChannelView to JSON.
   */
  encode: function (msg: Partial<ChannelView>): string {
    return JSON.stringify(ChannelViewJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelView from JSON.
   */
  decode: function (json: string): ChannelView {
    return ChannelViewJSON._readMessage(
      ChannelViewJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelView with all fields set to their default value.
   */
  initialize: function (): ChannelView {
    return {
      channel: Channel.initialize(),
      createdBy: User.initialize(),
      members: [],
      messages: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<ChannelView>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.channel) {
      const channel = ChannelJSON._writeMessage(msg.channel);
      if (Object.keys(channel).length > 0) {
        json.channel = channel;
      }
    }
    if (msg.createdBy) {
      const createdBy = UserJSON._writeMessage(msg.createdBy);
      if (Object.keys(createdBy).length > 0) {
        json.createdBy = createdBy;
      }
    }
    if (msg.members?.length) {
      json.members = msg.members.map(ChannelMemberViewJSON._writeMessage);
    }
    if (msg.messages?.length) {
      json.messages = msg.messages.map(MessageViewJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChannelView, json: any): ChannelView {
    const _channel = json.channel;
    if (_channel) {
      const m = Channel.initialize();
      ChannelJSON._readMessage(m, _channel);
      msg.channel = m;
    }
    const _createdBy = json.createdBy ?? json.created_by;
    if (_createdBy) {
      const m = User.initialize();
      UserJSON._readMessage(m, _createdBy);
      msg.createdBy = m;
    }
    const _members = json.members;
    if (_members) {
      for (const item of _members) {
        const m = ChannelMemberView.initialize();
        ChannelMemberViewJSON._readMessage(m, item);
        msg.members.push(m);
      }
    }
    const _messages = json.messages;
    if (_messages) {
      for (const item of _messages) {
        const m = MessageView.initialize();
        MessageViewJSON._readMessage(m, item);
        msg.messages.push(m);
      }
    }
    return msg;
  },
};

export const ChannelMemberJSON = {
  /**
   * Serializes ChannelMember to JSON.
   */
  encode: function (msg: Partial<ChannelMember>): string {
    return JSON.stringify(ChannelMemberJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelMember from JSON.
   */
  decode: function (json: string): ChannelMember {
    return ChannelMemberJSON._readMessage(
      ChannelMemberJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelMember with all fields set to their default value.
   */
  initialize: function (): ChannelMember {
    return {
      userId: "",
      channelRole: "",
      invitation: ChannelMemberInvitation.initialize(),
      ban: ChannelMemberBan.initialize(),
      createdAt: Timestamp.initialize(),
      updatedAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelMember>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.userId) {
      json.userId = msg.userId;
    }
    if (msg.channelRole) {
      json.channelRole = msg.channelRole;
    }
    if (msg.invitation) {
      const invitation = ChannelMemberInvitationJSON._writeMessage(
        msg.invitation
      );
      if (Object.keys(invitation).length > 0) {
        json.invitation = invitation;
      }
    }
    if (msg.ban) {
      const ban = ChannelMemberBanJSON._writeMessage(msg.ban);
      if (Object.keys(ban).length > 0) {
        json.ban = ban;
      }
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.updatedAt) {
      const updatedAt = TimestampJSON._writeMessage(msg.updatedAt);
      if (Object.keys(updatedAt).length > 0) {
        json.updatedAt = updatedAt;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChannelMember, json: any): ChannelMember {
    const _userId = json.userId ?? json.user_id;
    if (_userId) {
      msg.userId = _userId;
    }
    const _channelRole = json.channelRole ?? json.channel_role;
    if (_channelRole) {
      msg.channelRole = _channelRole;
    }
    const _invitation = json.invitation;
    if (_invitation) {
      const m = ChannelMemberInvitation.initialize();
      ChannelMemberInvitationJSON._readMessage(m, _invitation);
      msg.invitation = m;
    }
    const _ban = json.ban;
    if (_ban) {
      const m = ChannelMemberBan.initialize();
      ChannelMemberBanJSON._readMessage(m, _ban);
      msg.ban = m;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _updatedAt = json.updatedAt ?? json.updated_at;
    if (_updatedAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _updatedAt);
      msg.updatedAt = m;
    }
    return msg;
  },
};

export const ChannelMemberViewJSON = {
  /**
   * Serializes ChannelMemberView to JSON.
   */
  encode: function (msg: Partial<ChannelMemberView>): string {
    return JSON.stringify(ChannelMemberViewJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelMemberView from JSON.
   */
  decode: function (json: string): ChannelMemberView {
    return ChannelMemberViewJSON._readMessage(
      ChannelMemberViewJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelMemberView with all fields set to their default value.
   */
  initialize: function (): ChannelMemberView {
    return {
      channelMember: ChannelMember.initialize(),
      user: User.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelMemberView>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.channelMember) {
      const channelMember = ChannelMemberJSON._writeMessage(msg.channelMember);
      if (Object.keys(channelMember).length > 0) {
        json.channelMember = channelMember;
      }
    }
    if (msg.user) {
      const user = UserJSON._writeMessage(msg.user);
      if (Object.keys(user).length > 0) {
        json.user = user;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelMemberView,
    json: any
  ): ChannelMemberView {
    const _channelMember = json.channelMember ?? json.channel_member;
    if (_channelMember) {
      const m = ChannelMember.initialize();
      ChannelMemberJSON._readMessage(m, _channelMember);
      msg.channelMember = m;
    }
    const _user = json.user;
    if (_user) {
      const m = User.initialize();
      UserJSON._readMessage(m, _user);
      msg.user = m;
    }
    return msg;
  },
};

export const ChannelMemberInvitationJSON = {
  /**
   * Serializes ChannelMemberInvitation to JSON.
   */
  encode: function (msg: Partial<ChannelMemberInvitation>): string {
    return JSON.stringify(ChannelMemberInvitationJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelMemberInvitation from JSON.
   */
  decode: function (json: string): ChannelMemberInvitation {
    return ChannelMemberInvitationJSON._readMessage(
      ChannelMemberInvitationJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelMemberInvitation with all fields set to their default value.
   */
  initialize: function (): ChannelMemberInvitation {
    return {
      acceptedAt: Timestamp.initialize(),
      rejectedAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelMemberInvitation>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.acceptedAt) {
      const acceptedAt = TimestampJSON._writeMessage(msg.acceptedAt);
      if (Object.keys(acceptedAt).length > 0) {
        json.acceptedAt = acceptedAt;
      }
    }
    if (msg.rejectedAt) {
      const rejectedAt = TimestampJSON._writeMessage(msg.rejectedAt);
      if (Object.keys(rejectedAt).length > 0) {
        json.rejectedAt = rejectedAt;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelMemberInvitation,
    json: any
  ): ChannelMemberInvitation {
    const _acceptedAt = json.acceptedAt ?? json.accepted_at;
    if (_acceptedAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _acceptedAt);
      msg.acceptedAt = m;
    }
    const _rejectedAt = json.rejectedAt ?? json.rejected_at;
    if (_rejectedAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _rejectedAt);
      msg.rejectedAt = m;
    }
    return msg;
  },
};

export const ChannelMemberBanJSON = {
  /**
   * Serializes ChannelMemberBan to JSON.
   */
  encode: function (msg: Partial<ChannelMemberBan>): string {
    return JSON.stringify(ChannelMemberBanJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelMemberBan from JSON.
   */
  decode: function (json: string): ChannelMemberBan {
    return ChannelMemberBanJSON._readMessage(
      ChannelMemberBanJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelMemberBan with all fields set to their default value.
   */
  initialize: function (): ChannelMemberBan {
    return {
      expiresAt: Timestamp.initialize(),
      shadow: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelMemberBan>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.expiresAt) {
      const expiresAt = TimestampJSON._writeMessage(msg.expiresAt);
      if (Object.keys(expiresAt).length > 0) {
        json.expiresAt = expiresAt;
      }
    }
    if (msg.shadow) {
      json.shadow = msg.shadow;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChannelMemberBan, json: any): ChannelMemberBan {
    const _expiresAt = json.expiresAt ?? json.expires_at;
    if (_expiresAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _expiresAt);
      msg.expiresAt = m;
    }
    const _shadow = json.shadow;
    if (_shadow) {
      msg.shadow = _shadow;
    }
    return msg;
  },
};

export const ChannelIdentifierJSON = {
  /**
   * Serializes ChannelIdentifier to JSON.
   */
  encode: function (msg: Partial<ChannelIdentifier>): string {
    return JSON.stringify(ChannelIdentifierJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelIdentifier from JSON.
   */
  decode: function (json: string): ChannelIdentifier {
    return ChannelIdentifierJSON._readMessage(
      ChannelIdentifierJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelIdentifier with all fields set to their default value.
   */
  initialize: function (): ChannelIdentifier {
    return {
      type: "",
      id: "",
      memberIds: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelIdentifier>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.type) {
      json.type = msg.type;
    }
    if (msg.id) {
      json.id = msg.id;
    }
    if (msg.memberIds?.length) {
      json.memberIds = msg.memberIds;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ChannelIdentifier,
    json: any
  ): ChannelIdentifier {
    const _type = json.type;
    if (_type) {
      msg.type = _type;
    }
    const _id = json.id;
    if (_id) {
      msg.id = _id;
    }
    const _memberIds = json.memberIds ?? json.member_ids;
    if (_memberIds) {
      msg.memberIds = _memberIds;
    }
    return msg;
  },
};

export const ChannelCommandJSON = {
  /**
   * Serializes ChannelCommand to JSON.
   */
  encode: function (msg: Partial<ChannelCommand>): string {
    return JSON.stringify(ChannelCommandJSON._writeMessage(msg));
  },

  /**
   * Deserializes ChannelCommand from JSON.
   */
  decode: function (json: string): ChannelCommand {
    return ChannelCommandJSON._readMessage(
      ChannelCommandJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ChannelCommand with all fields set to their default value.
   */
  initialize: function (): ChannelCommand {
    return {
      name: "",
      description: "",
      args: "",
      set: "",
      createdAt: Timestamp.initialize(),
      updatedAt: Timestamp.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ChannelCommand>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.description) {
      json.description = msg.description;
    }
    if (msg.args) {
      json.args = msg.args;
    }
    if (msg.set) {
      json.set = msg.set;
    }
    if (msg.createdAt) {
      const createdAt = TimestampJSON._writeMessage(msg.createdAt);
      if (Object.keys(createdAt).length > 0) {
        json.createdAt = createdAt;
      }
    }
    if (msg.updatedAt) {
      const updatedAt = TimestampJSON._writeMessage(msg.updatedAt);
      if (Object.keys(updatedAt).length > 0) {
        json.updatedAt = updatedAt;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ChannelCommand, json: any): ChannelCommand {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _description = json.description;
    if (_description) {
      msg.description = _description;
    }
    const _args = json.args;
    if (_args) {
      msg.args = _args;
    }
    const _set = json.set;
    if (_set) {
      msg.set = _set;
    }
    const _createdAt = json.createdAt ?? json.created_at;
    if (_createdAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _createdAt);
      msg.createdAt = m;
    }
    const _updatedAt = json.updatedAt ?? json.updated_at;
    if (_updatedAt) {
      const m = Timestamp.initialize();
      TimestampJSON._readMessage(m, _updatedAt);
      msg.updatedAt = m;
    }
    return msg;
  },
};
