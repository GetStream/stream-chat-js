// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/struct.proto
/* eslint-disable */

import type { ByteSource } from "twirpscript";
import { BinaryReader, BinaryWriter } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 *  The JSON representation for `NullValue` is JSON `null`.
 */
export type NullValue = "NULL_VALUE";

/**
 * `Struct` represents a structured data value, consisting of fields
 * which map to dynamically typed values. In some languages, `Struct`
 * might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an
 * object. The details of that representation are described together
 * with the proto support for the language.
 *
 * The JSON representation for `Struct` is JSON object.
 */
export interface Struct {
  /**
   * Unordered map of dynamically typed values.
   */
  fields: Record<string, Struct.Fields["value"] | undefined>;
}

export declare namespace Struct {
  interface Fields {
    key: string;
    value: Value;
  }
}

/**
 * `Value` represents a dynamically typed value which can be either
 * null, a number, a string, a boolean, a recursive struct value, or a
 * list of values. A producer of value is expected to set one of these
 * variants. Absence of any variant indicates an error.
 *
 * The JSON representation for `Value` is JSON value.
 */
export interface Value {
  /**
   * Represents a null value.
   */
  nullValue?: NullValue | null | undefined;
  /**
   * Represents a double value.
   */
  numberValue?: number | null | undefined;
  /**
   * Represents a string value.
   */
  stringValue?: string | null | undefined;
  /**
   * Represents a boolean value.
   */
  boolValue?: boolean | null | undefined;
  /**
   * Represents a structured value.
   */
  structValue?: Struct | null | undefined;
  /**
   * Represents a repeated `Value`.
   */
  listValue?: ListValue | null | undefined;
}

/**
 * `ListValue` is a wrapper around a repeated field of values.
 *
 * The JSON representation for `ListValue` is JSON array.
 */
export interface ListValue {
  /**
   * Repeated field of dynamically typed values.
   */
  values: Value[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const NullValue = {
  /**
   * Null value.
   */
  NULL_VALUE: "NULL_VALUE",
  /**
   * @private
   */
  _fromInt: function (i: number): NullValue {
    switch (i) {
      case 0: {
        return "NULL_VALUE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as NullValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: NullValue): number {
    switch (i) {
      case "NULL_VALUE": {
        return 0;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const Struct = {
  /**
   * Serializes Struct to protobuf.
   */
  encode: function (msg: Partial<Struct>): Uint8Array {
    return Struct._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Struct from protobuf.
   */
  decode: function (bytes: ByteSource): Struct {
    return Struct._readMessage(Struct.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Struct with all fields set to their default value.
   */
  initialize: function (): Struct {
    return {
      fields: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Struct>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fields) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.fields).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        Struct.Fields._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Struct, reader: BinaryReader): Struct {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as Struct.Fields;
          reader.readMessage(map, Struct.Fields._readMessage);
          msg.fields[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Fields: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Struct.Fields>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Struct.Fields,
      reader: BinaryReader
    ): Struct.Fields {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = Value.initialize();
            reader.readMessage(msg.value, Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Value = {
  /**
   * Serializes Value to protobuf.
   */
  encode: function (msg: Partial<Value>): Uint8Array {
    return Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Value from protobuf.
   */
  decode: function (bytes: ByteSource): Value {
    return Value._readMessage(Value.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Value with all fields set to their default value.
   */
  initialize: function (): Value {
    return {
      nullValue: undefined,
      numberValue: undefined,
      stringValue: undefined,
      boolValue: undefined,
      structValue: undefined,
      listValue: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.nullValue != undefined) {
      writer.writeEnum(1, NullValue._toInt(msg.nullValue));
    }
    if (msg.numberValue != undefined) {
      writer.writeDouble(2, msg.numberValue);
    }
    if (msg.stringValue != undefined) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != undefined) {
      writer.writeBool(4, msg.boolValue);
    }
    if (msg.structValue != undefined) {
      writer.writeMessage(5, msg.structValue, Struct._writeMessage);
    }
    if (msg.listValue != undefined) {
      writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Value, reader: BinaryReader): Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nullValue = NullValue._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.numberValue = reader.readDouble();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        case 5: {
          msg.structValue = Struct.initialize();
          reader.readMessage(msg.structValue, Struct._readMessage);
          break;
        }
        case 6: {
          msg.listValue = ListValue.initialize();
          reader.readMessage(msg.listValue, ListValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListValue = {
  /**
   * Serializes ListValue to protobuf.
   */
  encode: function (msg: Partial<ListValue>): Uint8Array {
    return ListValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes ListValue from protobuf.
   */
  decode: function (bytes: ByteSource): ListValue {
    return ListValue._readMessage(
      ListValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes ListValue with all fields set to their default value.
   */
  initialize: function (): ListValue {
    return {
      values: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ListValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.values?.length) {
      writer.writeRepeatedMessage(1, msg.values as any, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListValue, reader: BinaryReader): ListValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Value.initialize();
          reader.readMessage(m, Value._readMessage);
          msg.values.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const NullValueJSON = {
  /**
   * Null value.
   */
  NULL_VALUE: "NULL_VALUE",
  /**
   * @private
   */
  _fromInt: function (i: number): NullValue {
    switch (i) {
      case 0: {
        return "NULL_VALUE";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as NullValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: NullValue): number {
    switch (i) {
      case "NULL_VALUE": {
        return 0;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const StructJSON = {
  /**
   * Serializes Struct to JSON.
   */
  encode: function (msg: Partial<Struct>): string {
    return JSON.stringify(StructJSON._writeMessage(msg));
  },

  /**
   * Deserializes Struct from JSON.
   */
  decode: function (json: string): Struct {
    return StructJSON._readMessage(StructJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Struct with all fields set to their default value.
   */
  initialize: function (): Struct {
    return {
      fields: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Struct>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fields) {
      const fields = Object.fromEntries(
        Object.entries(msg.fields)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(StructJSON.Fields._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fields).length > 0) {
        json.fields = fields;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Struct, json: any): Struct {
    const _fields = json.fields;
    if (_fields) {
      msg.fields = Object.fromEntries(
        Object.entries(_fields)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(StructJSON.Fields._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Fields: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Struct.Fields>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ValueJSON._writeMessage(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Struct.Fields, json: any): Struct.Fields {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        ValueJSON._readMessage(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const ValueJSON = {
  /**
   * Serializes Value to JSON.
   */
  encode: function (msg: Partial<Value>): string {
    return JSON.stringify(ValueJSON._writeMessage(msg));
  },

  /**
   * Deserializes Value from JSON.
   */
  decode: function (json: string): Value {
    return ValueJSON._readMessage(ValueJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Value with all fields set to their default value.
   */
  initialize: function (): Value {
    return {
      nullValue: undefined,
      numberValue: undefined,
      stringValue: undefined,
      boolValue: undefined,
      structValue: undefined,
      listValue: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Value>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.nullValue != undefined) {
      json.nullValue = msg.nullValue;
    }
    if (msg.numberValue != undefined) {
      json.numberValue = msg.numberValue;
    }
    if (msg.stringValue != undefined) {
      json.stringValue = msg.stringValue;
    }
    if (msg.boolValue != undefined) {
      json.boolValue = msg.boolValue;
    }
    if (msg.structValue != undefined) {
      const structValue = StructJSON._writeMessage(msg.structValue);
      json.structValue = structValue;
    }
    if (msg.listValue != undefined) {
      const listValue = ListValueJSON._writeMessage(msg.listValue);
      json.listValue = listValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Value, json: any): Value {
    const _nullValue = json.nullValue ?? json.null_value;
    if (_nullValue) {
      msg.nullValue = _nullValue;
    }
    const _numberValue = json.numberValue ?? json.number_value;
    if (_numberValue) {
      msg.numberValue = _numberValue;
    }
    const _stringValue = json.stringValue ?? json.string_value;
    if (_stringValue) {
      msg.stringValue = _stringValue;
    }
    const _boolValue = json.boolValue ?? json.bool_value;
    if (_boolValue) {
      msg.boolValue = _boolValue;
    }
    const _structValue = json.structValue ?? json.struct_value;
    if (_structValue) {
      const m = Struct.initialize();
      StructJSON._readMessage(m, _structValue);
      msg.structValue = m;
    }
    const _listValue = json.listValue ?? json.list_value;
    if (_listValue) {
      const m = ListValue.initialize();
      ListValueJSON._readMessage(m, _listValue);
      msg.listValue = m;
    }
    return msg;
  },
};

export const ListValueJSON = {
  /**
   * Serializes ListValue to JSON.
   */
  encode: function (msg: Partial<ListValue>): string {
    return JSON.stringify(ListValueJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListValue from JSON.
   */
  decode: function (json: string): ListValue {
    return ListValueJSON._readMessage(
      ListValueJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes ListValue with all fields set to their default value.
   */
  initialize: function (): ListValue {
    return {
      values: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<ListValue>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.values?.length) {
      json.values = msg.values.map(ValueJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListValue, json: any): ListValue {
    const _values = json.values;
    if (_values) {
      for (const item of _values) {
        const m = Value.initialize();
        ValueJSON._readMessage(m, item);
        msg.values.push(m);
      }
    }
    return msg;
  },
};
